<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>MindFlow â€” æç®€å¼ºå¤§çš„æ€ç»´å¯¼å›¾</title>
    <style>
        :root {
            --bg: #0f1115;
            --panel: #141821;
            --muted: #2a2f3a;
            --text: #e7ecf3;
            --sub: #a9b3c7;
            --accent: #5cc8ff;
            --accent2: #8b5cf6;
            --danger: #ff6b6b;
            --ok: #22c55e;
            --warn: #f59e0b;
            --edge: #394150;
            --shadow: 0 8px 24px rgba(0,0,0,.25);
            --node-bg: #171b24;
            --node-border: #2b3240;
            --node-focus: #5cc8ff;
            --tag-bg: #243042;
            --tag-text: #b6c9ff;
        }

        [data-theme="light"] {
            --bg: #f6f7fb;
            --panel: #ffffff;
            --muted: #e8ebf3;
            --text: #0f1220;
            --sub: #475069;
            --accent: #2563eb;
            --accent2: #7c3aed;
            --danger: #dc2626;
            --ok: #16a34a;
            --warn: #d97706;
            --edge: #c7d0e6;
            --shadow: 0 8px 24px rgba(28,41,61,.15);
            --node-bg: #ffffff;
            --node-border: #dde3f2;
            --node-focus: #2563eb;
            --tag-bg: #e8efff;
            --tag-text: #274690;
        }

        html, body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font: 14px/1.25 system-ui,Segoe UI,Roboto,Helvetica,Arial;
        }

        #app {
            display: grid;
            grid-template-rows: auto 1fr auto;
            height: 100%;
        }
        /* é¡¶éƒ¨å·¥å…·æ  */
        .toolbar {
            display: flex;
            gap: 6px;
            align-items: center;
            padding: 8px 10px;
            background: var(--panel);
            box-shadow: var(--shadow);
            position: sticky;
            top: 0;
            z-index: 10
        }

        .btn, .seg > button, select, input[type="color"] {
            border: 1px solid var(--muted);
            background: transparent;
            color: var(--text);
            border-radius: 8px;
            padding: 8px 10px;
            cursor: pointer
        }

            .btn:hover, .seg > button:hover {
                background: var(--muted)
            }

        .seg {
            display: inline-flex;
            border: 1px solid var(--muted);
            border-radius: 10px;
            overflow: hidden
        }

            .seg > button {
                border: 0;
                border-right: 1px solid var(--muted)
            }

                .seg > button:last-child {
                    border-right: 0
                }

        .grow {
            flex: 1
        }

        .kbd {
            padding: .2em .5em;
            border: 1px solid var(--muted);
            border-radius: 6px;
            color: var(--sub)
        }

        .divider {
            width: 1px;
            background: var(--muted);
            height: 28px;
            margin: 0 6px
        }

        .status {
            color: var(--sub)
        }
        /* ç”»å¸ƒä¸è¿·ä½ åœ°å›¾ */
        #stageWrap {
            position: relative;
            overflow: hidden;
            background: repeating-conic-gradient(from 0deg at 50% 50%,transparent 0 25deg, #0000 25deg 50deg),radial-gradient(1200px 600px at 70% 20%,rgba(92,200,255,.05),transparent 45%);
        }

        #grid {
            position: absolute;
            inset: 0;
            pointer-events: none;
            background: linear-gradient(to right, var(--muted) 1px, transparent 1px) 0 0/40px 40px, linear-gradient(to bottom, var(--muted) 1px, transparent 1px) 0 0/40px 40px;
            opacity: .15
        }

        svg {
            width: 100%;
            height: 100%
        }

        #minimap {
            position: absolute;
            right: 12px;
            bottom: 12px;
            width: 200px;
            height: 140px;
            background: var(--panel);
            border: 1px solid var(--muted);
            border-radius: 10px;
            box-shadow: var(--shadow);
            overflow: hidden
        }

        #miniSvg {
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom right, rgba(92,200,255,.08), transparent)
        }

        #miniViewport {
            fill: rgba(140,180,255,.18);
            stroke: var(--accent)
        }
        /* èŠ‚ç‚¹è§†è§‰ */
        .node {
            cursor: default
        }

            .node rect {
                fill: var(--node-bg);
                stroke: var(--node-border);
                stroke-width: 1.5;
                rx: 10;
                ry: 10;
                filter: drop-shadow(0 6px 10px rgba(0,0,0,.25))
            }

            .node[data-selected="true"] rect {
                stroke: var(--node-focus);
                stroke-width: 2
            }
            rect.search-hit {
                stroke: var(--accent2) !important;
                stroke-width: 2.4px !important;
            }
            /* æœç´¢é«˜äº®ï¼ˆå¼ºåˆ¶ç½®é¡¶ï¼‰ */
            .node rect[style*="var(--accent2)"] {
                stroke: var(--accent2) !important;
                stroke-width: 2.4px !important;
            }

            .node .title {
                font-weight: 600
            }

            .node .meta {
                fill: var(--sub);
                font-size: 11px
            }

        .badge {
            font-size: 10px;
            fill: var(--tag-text)
        }

        .badge-bg {
            fill: var(--tag-bg);
            rx: 6;
            ry: 6
        }

        .collapse-hit {
            cursor: pointer
        }

        .collapse-btn {
            fill: var(--sub)
        }

        .edge {
            stroke: var(--edge);
            stroke-width: 2;
            fill: none
        }

            .edge[data-highlight="true"] {
                stroke: var(--accent)
            }

        #selectionBox {
            stroke: var(--accent);
            fill: rgba(92,200,255,.15);
            stroke-dasharray: 4 4;
            pointer-events: none
        }
        /* åº•éƒ¨ */
        .footer {
            display: flex;
            gap: 12px;
            align-items: center;
            padding: 8px 10px;
            background: var(--panel);
            color: var(--sub)
        }
        /* å¼¹å‡ºé¢æ¿ */
        .floating {
            position: absolute;
            background: var(--panel);
            border: 1px solid var(--muted);
            border-radius: 12px;
            padding: 10px;
            box-shadow: var(--shadow);
            z-index: 12;
            min-width: 260px
        }

        .row {
            display: flex;
            gap: 8px;
            align-items: center;
            margin: 6px 0
        }

            .row label {
                width: 80px;
                color: var(--sub)
            }

            .row input[type="text"], .row textarea, .row select {
                flex: 1;
                border: 1px solid var(--muted);
                background: transparent;
                color: var(--text);
                border-radius: 8px;
                padding: 8px
            }

            .row textarea {
                height: 80px;
                resize: vertical
            }

        .chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border: 1px solid var(--muted);
            border-radius: 999px;
            color: var(--sub);
            cursor: pointer
        }

            .chip.active {
                border-color: var(--accent);
                color: var(--text)
            }

        .icon {
            font-variation-settings: 'FILL' 1, 'opsz' 24, 'wght' 400;
            font-family: 'Material Symbols Outlined', sans-serif;
        }

        @font-face {
            font-family: "Material Symbols Outlined";
            src: local("Material Symbols Outlined"), local("MaterialSymbolsOutlined");
            unicode-range: U+E000-FFFF;
        }

        /* library overlay */
        .libraryOverlay {
            position: fixed;
            inset: 0;
            background: rgba(6,8,12,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 60
        }

        .libraryBox {
            width: 960px;
            max-width: 96%;
            background: var(--panel);
            border: 1px solid var(--muted);
            border-radius: 12px;
            padding: 16px;
            box-shadow: var(--shadow);
            color: var(--text);
            display: flex;
            flex-direction: column;
            gap: 10px
        }

        .libraryHeader {
            display: flex;
            align-items: center;
            gap: 8px
        }

        .libraryList {
            display: flex;
            gap: 12px
        }

        .maps {
            width: 320px;
            border-right: 1px solid var(--muted);
            padding-right: 12px;
            max-height: 520px;
            overflow: auto
        }

        .mapItem {
            padding: 8px;
            border-radius: 8px;
            border: 1px solid transparent;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            cursor: pointer
        }

            .mapItem:hover {
                background: rgba(255,255,255,0.02)
            }

            .mapItem.active {
                border-color: var(--accent)
            }

        .mapMeta {
            flex: 1
        }

        .mapActions {
            display: flex;
            gap: 6px
        }

        .mapPreview {
            flex: 1;
            padding-left: 12px;
            max-height: 520px;
            overflow: auto
        }

        .small {
            font-size: 12px;
            color: var(--sub)
        }
        /* æœç´¢é«˜äº®ï¼šä»…å¯¹ã€Œæœªè¢«é€‰ä¸­ã€çš„èŠ‚ç‚¹ç”Ÿæ•ˆ */
        .node:not([data-selected="true"]) rect.search-hit {
            stroke: var(--accent2) !important; /* ç´«è‰² */
            stroke-width: 2.4px !important;
        }

        /* å½“å‰é€‰ä¸­èŠ‚ç‚¹ï¼šä¿æŒè“è‰²ï¼Œä¼˜å…ˆçº§æœ€é«˜ */
        .node[data-selected="true"] rect {
            stroke: var(--node-focus) !important;
            stroke-width: 2px !important;
        }
        #btnAutoLayout.active {
            background: var(--accent);
            color: var(--bg);
        }
    </style>
</head>
<body data-theme="light">
    <div id="libraryOverlay" class="libraryOverlay" style="display:none">
        <div class="libraryBox" role="dialog" aria-label="æˆ‘çš„æ€ç»´å¯¼å›¾åº“">
            <div class="libraryHeader">
                <h3 style="margin:0">æˆ‘çš„å¯¼å›¾</h3>
                <div style="flex:1"></div>
                <button class="btn" id="libNewBtn">æ–°å»ºå¯¼å›¾</button>
                <button class="btn" id="libImportBtn">å¯¼å…¥JSON</button>
                <button class="btn" id="libCloseBtn">å…³é—­</button>
                <input id="libFile" type="file" accept="application/json" hidden />
            </div>
            <div class="libraryList">
                <div class="maps" id="mapsList"></div>
                <div class="mapPreview" id="mapPreview">
                    <div class="small">é€‰ä¸­å¯¼å›¾åå¯ä»¥æŸ¥çœ‹é¢„è§ˆã€é‡å‘½åã€å¯¼å‡ºæˆ–åˆ é™¤ã€‚</div>
                </div>
            </div>
            <div style="text-align:right" class="small">æœ¬åœ°å­˜å‚¨ï¼šæµè§ˆå™¨ï¼ˆlocalStorageï¼‰ã€‚å¯åˆ›å»ºã€åˆ é™¤å¹¶æ‰“å¼€å¯¼å›¾ã€‚</div>
        </div>
    </div>

    <div id="app">
        <!-- é¡¶éƒ¨å·¥å…·æ  -->
        <div class="toolbar">
            <div class="seg">
                <button id="btnFileMenu">æ–‡ä»¶ â–¼</button>
            </div>

            <!-- æ–‡ä»¶ä¸‹æ‹‰æµ®å±‚ -->
            <div id="fileDropdown" class="floating" style="display:none;top:40px;left:10px;min-width:160px;">
                <button class="btn" style="width:100%;" id="btnNew">æ–°å»º</button>
                <button class="btn" style="width:100%;" id="btnOpen">å¯¼å…¥ JSON</button>
                <button class="btn" style="width:100%;" id="btnSave">å¯¼å‡º JSON</button>
                <button class="btn" style="width:100%;" id="btnSvg">å¯¼å‡º SVG</button>
                <button class="btn" style="width:100%;" id="btnPng">å¯¼å‡º PNG</button>
                <button id="btnAISummary">AI æ€»ç»“ä¸ºå¯¼å›¾</button><textarea id="aiInput" placeholder="ç²˜è´´æ–‡æœ¬æˆ–çŸ¥è¯†ç‚¹..."></textarea>

            </div>
           
            <!-- è®¾ç½®ä¸‹æ‹‰æµ®å±‚ -->
            <div id="settingsDropdown" class="floating" style="display:none;top:40px;left:10px;min-width:160px;">
                <label style="display:flex;align-items:center;gap:6px;padding:4px 8px;">
                    <input type="checkbox" id="cbAutoLayout">
                    è‡ªåŠ¨æ•´ç†
                </label>
            </div>
            <!-- è‡ªåŠ¨æ•´ç†å¼€å…³ -->
            <div class="">
                <button id="btnAutoLayout" class="btn" title="å±•å¼€/æŠ˜å æ—¶è‡ªåŠ¨æ•´ç†ä½ç½®">è‡ªåŠ¨æ•´ç†</button>
            </div>
            <div class="divider"></div>
            <div class="seg">
                <button id="btnAddSibling">åŒçº§(Enter)</button>
                <button id="btnAddParent">çˆ¶çº§(F)</button>
                <button id="btnAddChild">å­çº§(Tab)</button>
                <button id="btnDelete">åˆ é™¤(/)</button>
                <button class="btn" id="btnOrphan">ç©ºç™½èŠ‚ç‚¹</button>
            </div>
            <div class="seg">
                <button id="btnLayoutRight">å¸ƒå±€: å³(1)</button>
                <button id="btnLayoutBoth">å·¦å³(2)</button>
                <button id="btnLayoutRadial">æ”¾å°„(3)</button>
            </div>
            <div class="seg">
                <button id="btnUndo">æ’¤é”€</button>
                <button id="btnRedo">é‡åš</button>
            </div>
            <div class="seg">
                <button id="btnTheme">ä¸»é¢˜</button>
                <button id="btnFit">è‡ªé€‚åº”</button>
                <button class="btn" id="btnSelMode">ç‚¹é€‰æ¨¡å¼</button>
                <button id="btnCenter">å›åˆ°æ ¹</button>
            </div>

            <button class="btn" id="btnLibrary">æˆ‘çš„å¯¼å›¾</button>
            <button class="btn" id="btnSaveMap">ä¿å­˜åˆ°åº“</button>

            <input id="search" class="grow" placeholder="æœç´¢èŠ‚ç‚¹ï¼ˆæ”¯æŒæ­£åˆ™ï¼‰â€¦  (Ctrl/Cmd+F)" />
            <!-- ç•Œé¢ â–¼ -->
            <div class="seg">
                <button id="UIMenu">ç•Œé¢ â–¼</button>
            </div>

            <!-- ç•Œé¢ä¸‹æ‹‰æµ®å±‚ -->
            <div id="uiDropdown" class="floating" style="display:none;top:40px;left:10px;min-width:160px;">
                <button class="btn" style="width:100%;" id="btnNoteUI">å¤‡æ³¨</button>
                <button class="btn" style="width:100%;" id="btnLinkUI">é“¾æ¥</button>
                <button class="btn" style="width:100%;" id="btnImageUI">å›¾ç‰‡</button>
                <button class="btn" style="width:100%;" id="btnTaskUI">ä»»åŠ¡</button>
                <button class="btn" style="width:100%;" id="btnTagUI">æ ‡ç­¾</button>
                <button class="btn" style="width:100%;" id="btnStyleUI">æ ·å¼</button>
            </div>
            <span class="status" id="status"></span>
            <input id="fileOpen" type="file" accept="application/json" hidden />
        </div>

        <!-- ç”»å¸ƒ -->
        <div id="stageWrap">
            <div id="grid"></div>
            <svg id="stage">
                <defs>
                    <marker id="arrow" markerWidth="10" markerHeight="8" refX="10" refY="4" orient="auto">
                        <path d="M0,0 L10,4 L0,8 Z" fill="var(--edge)"></path>
                    </marker>
                </defs>
                <g id="world" transform="translate(0,0) scale(1)">
                    <g id="edges"></g>
                    <g id="nodes"></g>
                    <rect id="selectionBox" x="0" y="0" width="0" height="0" visibility="hidden"></rect>
                </g>
            </svg>
            <!-- è¿·ä½ åœ°å›¾ -->
            <div id="minimap">
                <svg id="miniSvg">
                    <g id="miniWorld"></g>
                    <rect id="miniViewport"></rect>
                </svg>
            </div>
        </div>

        <!-- åº•éƒ¨ -->
        <div class="footer">
            <span>æç¤ºï¼šæŒ‰ä½<span class="kbd">é»˜è®¤ä¸ç”¨æŒ‰</span>æ‹–åŠ¨ç”»å¸ƒï¼Œ<span class="kbd">/</span>åˆ é™¤èŠ‚ç‚¹ï¼Œ<span class="kbd">åŒå‡»</span>ç¼–è¾‘æ–‡æœ¬ã€‚</span>
            <button class="btn" id="btnShortcuts" style="margin-left:12px;">å¿«æ·é”®å¸®åŠ©</button>
            <span class="grow"></span>
            <span id="footMeta"></span>
            
        </div>
    </div>

    <!-- æµ®åŠ¨é¢æ¿ï¼ˆå¤ç”¨ï¼‰ -->
    <div id="panel" class="floating" style="display:none"></div>
    <div id="shortcutsModal" class="libraryOverlay" style="display:none">
        <div class="libraryBox" style="max-width:480px">
            <h3 style="margin:0 0 10px">å¿«æ·é”®ä¸€è§ˆ</h3>
            <pre style="white-space:pre-wrap;font-size:13px;line-height:1.4">
            Enter       æ–°å»ºåŒçº§èŠ‚ç‚¹
            Tab         æ–°å»ºå­èŠ‚ç‚¹
            Shift+Tab   æå‡ä¸ºçˆ¶çº§èŠ‚ç‚¹
            /           åˆ é™¤é€‰ä¸­èŠ‚ç‚¹ï¼ˆå«å¼¹çª—ç¡®è®¤ï¼‰
            Space       æŠ˜å /å±•å¼€èŠ‚ç‚¹
            Ctrl+Z      æ’¤é”€
            Ctrl+Y / Ctrl+Shift+Z  é‡åš
            1           å³ä¾§å¸ƒå±€
            2           å·¦å³å¸ƒå±€
            3           æ”¾å°„å¸ƒå±€
            + / -       æ”¾å¤§ / ç¼©å°
            R           é‡ç½®é€‰ä¸­èŠ‚ç‚¹åˆ°é»˜è®¤ä½ç½®
            .           é”å®š / è§£é”èŠ‚ç‚¹
            Shift+D     åˆ‡æ¢åˆ é™¤æ¨¡å¼
            Esc         é€€å‡º/è§£é”
        </pre>
            <div style="text-align:right;margin-top:10px">
                <button class="btn" id="closeShortcuts">å…³é—­</button>
            </div>
        </div>
    </div>

    <script>
       
        /* ---------------------- æ•°æ®ä¸å·¥å…· ---------------------- */
        const $ = s => document.querySelector(s);
        const $$ = s => Array.from(document.querySelectorAll(s));
        const rndId = () => Math.random().toString(36).slice(2, 9);
        const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
        const deepCopy = obj => JSON.parse(JSON.stringify(obj));
        const nowStr = () => new Date().toLocaleString();

        const LIB_KEY = 'mindflow_maps_v1';

        const appState = {

            layout: 'right', // right | both | radial
            theme: 'dark',
            scale: 1, tx: 0, ty: 0,
            selected: new Set(),
            hovered: null,
            editing: null,
            dragging: null,
            marquee: null,
            history: { past: [], future: [] },
            searchRe: null,
            currentMapId: null,
            lockNodes: false,   // æ–°å¢ï¼šé”å®šèŠ‚ç‚¹
            // æ”¾åœ¨ appState ä»»æ„ä½ç½®
            imageDragging: null,   // { node, startX, startY }
            deleteMode: 'all',   // 'all' | 'keep'   é»˜è®¤å…¨åˆ 
            manualLayout: new Set(), // è®°å½•å“ªäº›èŠ‚ç‚¹è¢«æ‰‹åŠ¨æ‹–æ”¾è¿‡
            selectMode: 'point',   // point | box
            orphanNodes: [],        // ä¿å­˜æ‰€æœ‰ç©ºç™½èŠ‚ç‚¹
            awaitingParent: null,   // è®°å½•å½“å‰æ­£åœ¨ç­‰å¾…æ–°çˆ¶èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ id
         
            marquee: null,          // ä¿ç•™æ¡†çŸ©å½¢
            marqueeDrag: null,      // æ¡†æ•´ä½“æ‹–åŠ¨
            /* ------------------- åœ¨ appState é‡Œå¢åŠ  ------------------- */
            viewMemory: {},               // ç»“æ„ï¼š{ nodeId: { collapsedTx, collapsedTy, collapsedScale, expandedTx, expandedTy, expandedScale } }

        };

        /* é»˜è®¤æ¨¡å‹ */
        let model = {
            id: 'root',
            text: 'ä¸­å¿ƒä¸»é¢˜',
            collapsed: false,
            x: 0, y: 0,
            style: { fill: '#ffffff', bg: null, border: null, w: 0, h: 0, icon: 'ğŸ§ ', shape: 'round' },
            meta: { note: 'åŒå‡»èŠ‚ç‚¹ä»¥ç¼–è¾‘ï¼›Tab åˆ›å»ºå­èŠ‚ç‚¹ï¼›Enter åˆ›å»ºåŒçº§ã€‚', link: '', img: '', task: false, progress: 0, priority: 0, tags: [] },
            children: [
                { id: rndId(), text: 'åˆ†æ”¯A', children: [], collapsed: false, style: {}, meta: { tags: ['èµ·æ­¥'] } },
                { id: rndId(), text: 'åˆ†æ”¯B', children: [], collapsed: false, style: {}, meta: { tags: ['é‡è¦'] } },
            ]
        };

        /* ---------------------- åº“ï¼ˆlocalStorageï¼‰ ---------------------- */
        function loadLibrary() {
            try {
                const raw = localStorage.getItem(LIB_KEY);
                if (!raw) return [];
                return JSON.parse(raw);
            } catch (e) { console.error(e); return []; }
        }
        function saveLibrary(list) {
            localStorage.setItem(LIB_KEY, JSON.stringify(list));
        }
        function renderLibrary() {
            const lib = loadLibrary();
            const listEl = $('#mapsList');
            listEl.innerHTML = '';
            lib.forEach(m => {
                const div = document.createElement('div'); div.className = 'mapItem'; div.dataset.id = m.id;
                const md = document.createElement('div'); md.className = 'mapMeta';
                md.innerHTML = `<div style="font-weight:600">${escapeHtml(m.name || ('æœªå‘½å-' + m.id))}</div><div class="small">${new Date(m.updated || m.created).toLocaleString()}</div>`;
                const actions = document.createElement('div'); actions.className = 'mapActions';
                const openBtn = document.createElement('button'); openBtn.className = 'btn'; openBtn.textContent = 'æ‰“å¼€';
                const exportBtn = document.createElement('button'); exportBtn.className = 'btn'; exportBtn.textContent = 'å¯¼å‡º';
                const delBtn = document.createElement('button'); delBtn.className = 'btn'; delBtn.textContent = 'åˆ é™¤';
                const renameBtn = document.createElement('button'); renameBtn.className = 'btn'; renameBtn.textContent = 'é‡å‘½å';
                actions.appendChild(openBtn); actions.appendChild(exportBtn); actions.appendChild(renameBtn); actions.appendChild(delBtn);
                div.appendChild(md); div.appendChild(actions);
                openBtn.addEventListener('click', () => { openMap(m.id); });
                exportBtn.addEventListener('click', () => { exportMap(m.id); });
                renameBtn.addEventListener('click', () => { const n = prompt('é‡å‘½å', m.name || ''); if (n != null) { m.name = n; m.updated = Date.now(); saveLibrary(lib); renderLibrary(); } });
                delBtn.addEventListener('click', () => { if (confirm('åˆ é™¤å¯¼å›¾â€œ' + (m.name || 'æœªå‘½å') + 'â€ï¼Ÿ')) { const idx = lib.findIndex(x => x.id === m.id); if (idx >= 0) { lib.splice(idx, 1); saveLibrary(lib); renderLibrary(); $('#mapPreview').innerHTML = ''; } } });
                div.addEventListener('click', (e) => {
                    if (e.target === div) { // ç‚¹å‡»å¤–å£³ä¹Ÿé€‰ä¸­
                        // æ˜¾ç¤ºé¢„è§ˆ
                        $('#mapsList .mapItem').forEach(it => it.classList.remove('active'));
                        div.classList.add('active');
                        showPreview(m);
                    }
                });
                listEl.appendChild(div);
            });
            if (lib.length) { // è‡ªåŠ¨é€‰ä¸­ç¬¬ä¸€ä¸ª
                const first = lib[0];
                $('#mapsList .mapItem')?.[0]?.click?.();
            } else {
                $('#mapPreview').innerHTML = '<div class="small">æš‚æ— å¯¼å›¾ï¼Œç‚¹å‡»â€œæ–°å»ºå¯¼å›¾â€å¼€å§‹ã€‚</div>';
            }
        }
        function showPreview(m) {
            const el = $('#mapPreview');
            const title = `<div style="font-weight:700;margin-bottom:8px">${escapeHtml(m.name || 'æœªå‘½å')}</div>`;
            const meta = `<div class="small">åˆ›å»ºï¼š${new Date(m.created).toLocaleString()} Â· æ›´æ–°ï¼š${new Date(m.updated || m.created).toLocaleString()}</div>`;
            let preview = '';
            try {
                preview = '<pre style="white-space:pre-wrap;background:transparent;border-radius:8px;padding:8px;margin-top:8px;color:var(--sub);">' + escapeHtml(JSON.stringify(m.model?.text ? { root: m.model.text, children: (m.model.children || []).slice(0, 6).map(c => c.text) } : m.model, null, 2)) + '</pre>';
            } catch (e) { preview = '<div class="small">æ— æ³•ç”Ÿæˆé¢„è§ˆ</div>'; }
            el.innerHTML = title + meta + preview;
        }
        function createMapWithModel(name, mdl) {
            const lib = loadLibrary();
            const m = { id: rndId(), name: name || ('å¯¼å›¾-' + (new Date().toLocaleString())), model: deepCopy(mdl || { id: 'root', text: 'ä¸­å¿ƒä¸»é¢˜', style: {}, meta: { tags: [] }, children: [] }), created: Date.now(), updated: Date.now() };
            lib.unshift(m);
            saveLibrary(lib);
            renderLibrary();
            return m.id;
        }
        function openMap(id) {
            const lib = loadLibrary();
            const m = lib.find(x => x.id === id);
            if (!m) return alert('å¯¼å›¾æœªæ‰¾åˆ°');
            model = deepCopy(m.model);
            appState.currentMapId = id;
            appState.selected.clear();
            commitHistory('open map');
            hideLibrary();
            renderAll();
            setStatus('æ‰“å¼€ï¼š' + (m.name || 'æœªå‘½å'));
        }
        function exportMap(id) {
            const lib = loadLibrary();
            const m = lib.find(x => x.id === id);
            if (!m) return alert('å¯¼å›¾æœªæ‰¾åˆ°');
            const blob = new Blob([JSON.stringify(m.model, null, 2)], { type: 'application/json' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `mindflow-${(m.name || m.id).replace(/\s+/g, '_')}.json`; a.click();
        }
        function saveCurrentMap() {
    const lib = loadLibrary();
    if (appState.currentMapId) {
        const m = lib.find(x => x.id === appState.currentMapId);
        if (m) {
            m.model = deepCopy(model);
            m.updated = Date.now();
            saveLibrary(lib);
            renderLibrary();
            setStatus('å·²ä¿å­˜åˆ°åº“');
            return;
        }
    }
    const name = prompt('ä¸ºå½“å‰å¯¼å›¾å‘½åï¼š', model.text || 'æˆ‘æ–°çš„å¯¼å›¾');
    if (name == null) return;
    const id = createMapWithModel(name, model);
    appState.currentMapId = id;
    setStatus('å·²ä¿å­˜åˆ°åº“');
}



        document.addEventListener('DOMContentLoaded', () => {
            /* ===== æ–‡ä»¶ä¸‹æ‹‰èœå• ===== */
            const fileBtn = $('#btnFileMenu');
            const filePanel = $('#fileDropdown');
            fileBtn.addEventListener('click', () => {
                filePanel.style.display = filePanel.style.display === 'none' ? 'block' : 'none';
            });

            /* ç‚¹å‡»ç©ºç™½å…³é—­ */
            window.addEventListener('click', e => {
                if (!fileBtn.contains(e.target) && !filePanel.contains(e.target)) filePanel.style.display = 'none';
            });

            /* æŠŠæ—§æŒ‰é’®äº‹ä»¶æŒ‚åˆ°æ–°æŒ‰é’® */
            const btnNew = $('#btnNew');
            const btnOpen = $('#btnOpen');
            const btnSave = $('#btnSave');
            const btnSvg = $('#btnSvg');
            const btnPng = $('#btnPng');

            if (btnNew) {
                $('#btnNew').onclick = btnNew.onclick;
            }
            if (btnOpen) {
                $('#btnOpen').onclick = btnOpen.onclick;
            }
            if (btnSave) {
                $('#btnSave').onclick = btnSave.onclick;
            }
            if (btnSvg) {
                $('#btnSvg').onclick = btnSvg.onclick;
            }
            if (btnPng) {
                $('#btnPng').onclick = btnPng.onclick;
            }

            /* å¿«æ·é”®å¸®åŠ©æŒ‰é’®äº‹ä»¶ */
            const btnShortcuts = $('#btnShortcuts');
            const closeShortcuts = $('#closeShortcuts');

            if (btnShortcuts) {
                btnShortcuts.onclick = () => $('#shortcutsModal').style.display = 'flex';
            }
            if (closeShortcuts) {
                closeShortcuts.onclick = () => $('#shortcutsModal').style.display = 'none';
            }

            /* åˆå§‹åŒ– */
            bootstrap();
        });
        /* ---------------------- å†å²ï¼ˆæ’¤é”€/é‡åšï¼‰ ---------------------- */
        function commitHistory(label = 'edit') {
            appState.history.past.push({ label, snapshot: deepCopy(model), view: { tx: appState.tx, ty: appState.ty, scale: appState.scale } });
            appState.history.future.length = 0;
            setStatus('å·²ä¿å­˜ï¼š' + label);
        }
        function undo() {
            if (!appState.history.past.length) return;
            const cur = { snapshot: deepCopy(model), view: { tx: appState.tx, ty: appState.ty, scale: appState.scale } };
            const last = appState.history.past.pop();
            appState.history.future.push(cur);
            model = last.snapshot;
            Object.assign(appState, last.view);
            renderAll();
        }
        function redo() {
            if (!appState.history.future.length) return;
            const cur = { snapshot: deepCopy(model), view: { tx: appState.tx, ty: appState.ty, scale: appState.scale } };
            const next = appState.history.future.pop();
            appState.history.past.push(cur);
            model = next.snapshot;
            Object.assign(appState, next.view);
            renderAll();
        }

        /* ---------------------- éå†å·¥å…· ---------------------- */
        function walk(node, fn, parent = null, depth = 0, side = 1) {
            fn(node, parent, depth, side);
            if (node.children && !node.collapsed) {
                for (let i = 0; i < node.children.length; i++) {
                    const c = node.children[i];
                    const s = appState.layout === 'both' ? (i % 2 === 0 ? 1 : -1) : 1;
                    const radialS = appState.layout === 'radial' ? (i % 2 === 0 ? 1 : -1) : s;
                    walk(c, fn, node, depth + 1, radialS);
                }
            }
        }
        function findById(id, node = model, parent = null) {
            if (node.id === id) return { node, parent };
            for (const c of (node.children || [])) {
                const r = findById(id, c, node);
                if (r) return r;
            }
            // å†æŸ¥ç©ºç™½èŠ‚ç‚¹
            const orphan = appState.orphanNodes.find(o => o.id === id);
            if (orphan) return { node: orphan, parent: null };
            return null;
        }

        /* ---------------------- å¸ƒå±€ç®—æ³• ---------------------- */
        const measureSvg = (() => {
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            const text = document.createElementNS(svg.namespaceURI, 'text');
            text.setAttribute('class', 'title');
            svg.appendChild(text);
            svg.style.position = 'absolute'; svg.style.opacity = '0'; document.body.appendChild(svg);
            return (str, metaLine = '') => {
                text.textContent = str || ' ';
                const bb = text.getBBox();
                const metaW = metaLine ? (metaLine.length * 6 + 20) : 0;
                const w = Math.max(bb.width + 28, 80, metaW);
                const h = Math.max(bb.height + 24 + (metaLine ? 18 : 0), 28);
                return { w, h };
            }
        })();

        function autoLayout() {
            /* ------------ 1. å…ˆç»™æ‰€æœ‰èŠ‚ç‚¹é‡å°ºå¯¸ ------------ */
            walk(model, (n) => {
                const metaLine = [
                    n.meta?.progress ? `${n.meta.progress}%` : '',
                    n.meta?.priority ? `P${n.meta.priority}` : '',
                    (n.meta?.tags || []).slice(0, 3).join(','),
                ].filter(Boolean).join(' Â· ');
                const m = measureSvg(n.text, metaLine);
                n.style = n.style || {};
                n.style.w = m.w;
                n.style.h = m.h;
                if (!n.meta.imgX) n.meta.imgX = n.x + n.style.w;
                if (!n.meta.imgY) n.meta.imgY = n.y;
            });

            const baseGap = 60;   // æ°´å¹³åŸºç¡€å®‰å…¨é—´è·
            const siblingGap = 25;   // å…„å¼ŸèŠ‚ç‚¹å‚ç›´é—´è·

            function sizeOf(node) {
                if (node.collapsed || !node.children?.length) return node.style.h;
                let sum = 0;
                for (const c of node.children) sum += sizeOf(c) + siblingGap;
                sum -= siblingGap;
                return Math.max(sum, node.style.h);
            }

            /* ------------ 4ï¸âƒ£ é€’å½’æ”¾ç½®èŠ‚ç‚¹ï¼ˆä»…æ”¹åŠ¨è¿™é‡Œï¼‰ ------------ */
            function place(node, x, y, side = 1) {
                node.x = x;
                node.y = y;
                if (node.collapsed || !node.children?.length) return;

                /* 4-1  è®¡ç®—ä¸‹ä¸€å±‚æœ€é•¿å­èŠ‚ç‚¹å®½åº¦ */
                const maxChildW = node.children.reduce(
                    (max, c) => Math.max(max, c.style?.w || 0),
                    0
                );

                /* 4-2  æ°´å¹³è·ç¦» = çˆ¶åŠå®½ + æœ€é•¿å­åŠå®½ + åŸºç¡€é—´è· */
                const parentHalfW = (node.style?.w || 120) / 2;
                const childHalfW = maxChildW / 2;
                const nextX = x + (parentHalfW + childHalfW + baseGap) * side;

                /* 4-3  å‚ç›´å¸ƒå±€ä¿æŒä¸å˜ */
                const totalH = node.children.reduce(
                    (s, c) => s + sizeOf(c) + siblingGap,
                    0
                ) - siblingGap;

                let curY = y - totalH / 2;
                for (const c of node.children) {
                    if (c.__manual) {
                        curY += (c.style?.h || 28) + siblingGap;
                        continue;
                    }
                    const childH = sizeOf(c);
                    place(c, nextX, curY + childH / 2, side);
                    curY += childH + siblingGap;
                }
            }

            place(model, 0, 0, 1);
        }

        /* ---------------------- æ¸²æŸ“ ---------------------- */
        function renderAll() {
            autoLayout();
            renderEdges();
            renderNodes();
            updateView();
            updateMiniMap();
            updateFooter();
            appState.orphanNodes.forEach(n => {
                const m = measureSvg(n.text);
                n.style = n.style || {};
                n.style.w = m.w; n.style.h = m.h;
            });
        }
        function renderEdges() {
            const g = $('#edges');
            g.innerHTML = '';
            walk(model, (n, p) => {
                if (!p) return;
                const path = document.createElementNS(g.namespaceURI, 'path');
                path.classList.add('edge');
                const sx = p.x + (p.style.w / 2);
                const sy = p.y;
                const tx = n.x - (n.style.w / 2);
                const ty = n.y;
                const dx = (tx - sx) * .6;
                const d = `M ${sx} ${sy} C ${sx + dx} ${sy}, ${tx - dx} ${ty}, ${tx} ${ty}`;
                path.setAttribute('d', d);
                path.setAttribute('marker-end', 'url(#arrow)');
                g.appendChild(path);
            });
        }
        function renderNodes() {
            const g = $('#nodes');
            g.innerHTML = '';
            walk(model, (n, p) => {
                const node = document.createElementNS(g.namespaceURI, 'g');
                node.classList.add('node'); node.setAttribute('data-id', n.id);
                if (appState.selected.has(n.id)) node.setAttribute('data-selected', 'true');
                node.setAttribute('transform', `translate(${n.x - n.style.w / 2}, ${n.y - n.style.h / 2})`);

                const rect = document.createElementNS(g.namespaceURI, 'rect');
                rect.setAttribute('width', n.style.w);
                rect.setAttribute('height', n.style.h);
                if (n.style.bg) rect.setAttribute('fill', n.style.bg);
                if (n.style.border) rect.setAttribute('stroke', n.style.border);
                node.appendChild(rect);

                // æ ‡é¢˜
                const title = document.createElementNS(g.namespaceURI, 'text');
                title.setAttribute('x', 14); title.setAttribute('y', 18);
                title.setAttribute('class', 'title');
                title.textContent = (n.style.icon ? (n.style.icon + ' ') : '') + (n.text || 'ï¼ˆç©ºï¼‰');
                node.appendChild(title);

                // meta è¡Œ
                const meta = document.createElementNS(g.namespaceURI, 'text');
                meta.setAttribute('x', 14); meta.setAttribute('y', 36);
                meta.setAttribute('class', 'meta');
                const metaParts = [];
                if (n.meta?.task) metaParts.push('â˜‘ï¸');
                if (n.meta?.progress) metaParts.push(n.meta.progress + '%');
                if (n.meta?.priority) metaParts.push('P' + n.meta.priority);
                if (n.meta?.link) metaParts.push('ğŸ”—');
                if (n.meta?.img) metaParts.push('ğŸ–¼ï¸');
                if (n.meta?.note) metaParts.push('ğŸ“');
                meta.textContent = metaParts.join(' Â· ');
                node.appendChild(meta);

                // æ ‡ç­¾
                if (n.meta?.tags?.length) {
                    const tagG = document.createElementNS(g.namespaceURI, 'g');
                    let x = 14, y = n.style.h - 12;
                    n.meta.tags.slice(0, 3).forEach(t => {
                        const tb = document.createElementNS(g.namespaceURI, 'rect');
                        const tt = document.createElementNS(g.namespaceURI, 'text');
                        tt.setAttribute('x', x + 6); tt.setAttribute('y', y);
                        tt.setAttribute('class', 'badge'); tt.textContent = '#' + t;
                        const bb = { w: t.length * 7 + 14, h: 16 };
                        tb.setAttribute('x', x); tb.setAttribute('y', y - 12); tb.setAttribute('width', bb.w); tb.setAttribute('height', bb.h);
                        tb.setAttribute('class', 'badge-bg');
                        tagG.appendChild(tb); tagG.appendChild(tt);
                        x += bb.w + 6;
                    });
                    node.appendChild(tagG);
                }

                // æŠ˜å æŒ‰é’®ï¼ˆæ”¹ä¸ºæ›´å¯é çš„å¯ç‚¹åŒºåŸŸï¼‰
                if (n.children?.length) {
                    const cx = n.style.w - 16, cy = 12;
                    const hit = document.createElementNS(g.namespaceURI, 'rect');
                    hit.setAttribute('x', cx - 8); hit.setAttribute('y', cy - 8); hit.setAttribute('width', 16); hit.setAttribute('height', 16);
                    hit.setAttribute('class', 'collapse-hit');
                    // å…³é”®ï¼šç¡®ä¿é€æ˜ä½†å¯ç‚¹å‡»
                    hit.setAttribute('fill', 'black'); hit.setAttribute('fill-opacity', '0.01');
                    hit.setAttribute('pointer-events', 'all');
                    hit.addEventListener('click', (e) => { e.stopPropagation(); toggleCollapse(n.id); });
                    const plus = document.createElementNS(g.namespaceURI, 'text');
                    plus.setAttribute('x', cx - 4); plus.setAttribute('y', cy + 4); plus.setAttribute('class', 'collapse-btn');
                    plus.textContent = n.collapsed ? '+' : 'âˆ’';
                    node.appendChild(hit); node.appendChild(plus);
                }

                // æœç´¢é«˜äº®
                // æœç´¢é«˜äº®ï¼ˆå¼ºåˆ¶æ ·å¼ç±»ï¼‰
                // æœç´¢é«˜äº®ï¼šç»™ rect æ‰“ classï¼Œä¸ç›´æ¥å†™é¢œè‰²
                // ---------- æœç´¢é«˜äº® ----------
                if (appState.searchRe && appState.searchRe.test(n.text || '')) {
                    if (!isNodeHiddenByAncestor(n)) {
                        rect.classList.add('search-hit');          // èŠ‚ç‚¹è‡ªèº«æŸ“ç´«
                    } else {
                        const ancestor = firstUnCollapsedAncestor(n);
                        if (ancestor) ancestor.__ancestorHit = true;
                    }
                } else {
                    rect.classList.remove('search-hit');
                }

                // äº‹ä»¶
                node.addEventListener('mousedown', onNodeMouseDown);
               
                node.addEventListener('dblclick', () => editNode(n.id));

                // æ”¯æŒæ‹–æ‹½å›¾ç‰‡åˆ°èŠ‚ç‚¹ä¸Šä¼ ï¼ˆæ–‡ä»¶æˆ–URLï¼‰
                node.addEventListener('dragover', e => { e.preventDefault(); });
                node.addEventListener('drop', async (e) => {
                    e.preventDefault(); e.stopPropagation();
                    const dt = e.dataTransfer;
                    const id = n.id;
                    const r = findById(id);
                    if (!r) return;
                    if (dt.files && dt.files.length) {
                        const f = dt.files[0];
                        if (f.type && f.type.startsWith('image/')) {
                            const data = await fileToDataURL(f);
                            commitHistory('drop image');
                            r.node.meta.img = data;
                            r.node.meta.imgX = r.node.x + r.node.style.w; // å›¾ç‰‡çš„ x åæ ‡ä¸ºèŠ‚ç‚¹çš„å³è¾¹ç•Œ
                            r.node.meta.imgY = r.node.y; // å›¾ç‰‡çš„ y åæ ‡ä¸èŠ‚ç‚¹ç›¸åŒ
                            renderAll();
                            setStatus('å›¾ç‰‡å·²ä¸Šä¼ åˆ°èŠ‚ç‚¹');
                            return;
                        }
                    }
                    const url = dt.getData('text/uri-list') || dt.getData('text/plain');
                    if (url) {
                        commitHistory('drop image url');
                        r.node.meta.img = url;
                        r.node.meta.imgX = r.node.x; //r.node.style.w; // å›¾ç‰‡çš„ x åæ ‡ä¸ºèŠ‚ç‚¹çš„å³è¾¹ç•Œ
                        r.node.meta.imgY = r.node.y; // å›¾ç‰‡çš„ y åæ ‡ä¸èŠ‚ç‚¹ç›¸åŒ
                        renderAll();
                        setStatus('å›¾ç‰‡URLå·²è®¾ç½®');
                    }
                });

                // æ¸²æŸ“å›¾ç‰‡
                if (n.meta?.img) {
                    const img = document.createElementNS(g.namespaceURI, 'image');
                    img.setAttribute('x', n.meta.imgX || n.x);//(n.x + n.style.w)); // å›¾ç‰‡çš„ x åæ ‡ä¸ºèŠ‚ç‚¹çš„å³è¾¹ç•Œ
                    img.setAttribute('y', n.meta.imgY || n.y); // å›¾ç‰‡çš„ y åæ ‡ä¸èŠ‚ç‚¹ç›¸åŒ
                    img.setAttribute('width', n.meta?.imgW || 128);
                    img.setAttribute('height', n.meta?.imgH || 128);
                    img.setAttribute('href', n.meta.img);
                    img.setAttribute('class', 'node-img');  // âœ… ç»Ÿä¸€ class
                    img.setAttribute('data-node-id', n.id); // âœ… è®°å½•æ‰€å±èŠ‚ç‚¹
                    img.style.cursor = 'move';              // âœ… æç¤ºå¯ç§»åŠ¨
                    img.addEventListener('mousedown', onImageMouseDown, { passive: false });
                    node.appendChild(img);
                }

                g.appendChild(node);
            });
           
            // ç»™ç¥–å…ˆä¸Šç´«è‰²
            walk(model, n => {
                if (n.__ancestorHit) {
                    const el = document.querySelector(`.node[data-id="${n.id}"] rect`);
                    if (el) el.classList.add('search-hit');
                    delete n.__ancestorHit; // ç”¨å®Œå³ç„š
                }
            });
            /* ===== æ¸²æŸ“ç©ºç™½èŠ‚ç‚¹ ===== */
            
            appState.orphanNodes.forEach(n => {
                const m = measureSvg(n.text);
                n.style = n.style || {};
                n.style.w = m.w;
                n.style.h = m.h;
                const node = document.createElementNS(g.namespaceURI, 'g');
                node.classList.add('node');
                node.setAttribute('data-id', n.id);
                if (appState.selected.has(n.id)) node.setAttribute('data-selected', 'true');
                node.setAttribute('transform', `translate(${n.x - n.style.w / 2}, ${n.y - n.style.h / 2})`);

                const rect = document.createElementNS(g.namespaceURI, 'rect');
                rect.setAttribute('width', n.style.w);
                rect.setAttribute('height', n.style.h);
                rect.setAttribute('fill', 'var(--node-bg)');
                rect.setAttribute('stroke', 'var(--node-border)');
                node.appendChild(rect);

                const title = document.createElementNS(g.namespaceURI, 'text');
                title.setAttribute('x', 14); title.setAttribute('y', 18);
                title.setAttribute('class', 'title');
                title.textContent = n.text;
                node.appendChild(title);

                node.addEventListener('mousedown', onNodeMouseDown);
              
                node.addEventListener('dblclick', () => editNode(n.id));
                g.appendChild(node);
            });
        }
        function onImageMouseDown(e) {
            if (!e.shiftKey) return;          // ä»… Shift è§¦å‘
            e.stopPropagation();              // é˜»æ–­èŠ‚ç‚¹é€‰ä¸­
            const id = e.currentTarget.getAttribute('data-node-id');
            const r = findById(id);
            if (!r) return;

            appState.imageDragging = {
                node: r.node,
                startX: e.clientX,
                startY: e.clientY,
            };

            window.addEventListener('mousemove', onImageMouseMove);
            window.addEventListener('mouseup', onImageMouseUp, { once: true });
        }

        function onImageMouseMove(e) {
            const drag = appState.imageDragging;
            if (!drag) return;
            const dx = e.clientX - drag.startX;
            const dy = e.clientY - drag.startY;

            // ç›´æ¥ä¿®æ”¹ meta ä¸­çš„åæ ‡
            drag.node.meta.imgX = (drag.node.meta.imgX ?? drag.node.x + drag.node.style.w) + dx;
            drag.node.meta.imgY = (drag.node.meta.imgY ?? drag.node.y) + dy;

            drag.startX = e.clientX;
            drag.startY = e.clientY;

            renderAll();
        }

        function onImageMouseUp() {
            if (appState.imageDragging) {
                commitHistory('move image');
                appState.imageDragging = null;
            }
            window.removeEventListener('mousemove', onImageMouseMove);
        }

        /* ---------------------- é€‰æ‹©/ç¼–è¾‘/ç»“æ„æ“ä½œ ---------------------- */
        function setStatus(s) { $('#status').textContent = s; }
        function selectOnly(id) { appState.selected = new Set([id]); renderNodes(); }
        function toggleSelect(id) {
            if (appState.selected.has(id)) appState.selected.delete(id); else appState.selected.add(id);
            renderNodes();
        }
        function currentId() {
            if (appState.selected.size) return Array.from(appState.selected)[appState.selected.size - 1];
            return model.id;
        }
        function addSibling() {
            const cur = findById(currentId());
            if (!cur || !cur.parent) return;

            commitHistory('add sibling');

            const sibling = {
                id: rndId(),
                text: 'æ–°èŠ‚ç‚¹',
                children: [],
                collapsed: false,
                style: {},
                meta: { tags: [] },
                x: cur.node.x , // âœ… è®¾ç½®åˆå§‹ä½ç½®
                y: cur.node.y-70, 
            };
            

            const m = measureSvg(sibling.text);
            sibling.style.w = m.w;
            sibling.style.h = m.h;

            cur.parent.children.splice(cur.parent.children.indexOf(cur.node) + 1, 0, sibling);
            
            selectOnly(sibling.id);
            renderAll();
            resolveOverlaps();
            renderAll();
        }//clearManualUpwards2(currentId());
        function addChild() {
            const cur = findById(currentId());
            if (!cur) return;

            commitHistory('add child');

            const child = {
                id: rndId(),
                text: 'å­èŠ‚ç‚¹',
                children: [],
                collapsed: false,
                style: {},
                meta: { tags: [] },
                x: cur.node.x + 140, // âœ… è®¾ç½®åˆå§‹ä½ç½®
                y: cur.node.y
            };

            const m = measureSvg(child.text);
            child.style.w = m.w;
            child.style.h = m.h;

            cur.node.children = cur.node.children || [];
            cur.node.children.push(child);
            cur.node.collapsed = false;

            
            selectOnly(child.id);
            renderAll();
            resolveOverlaps();
            renderAll();
        }//clearManualUpwards(currentId());

        function removeSelected() {
            if (appState.selected.size === 0) return;
            if (appState.selected.has(model.id)) return alert('ä¸èƒ½åˆ é™¤æ ¹èŠ‚ç‚¹');

            /* 0 = å–æ¶ˆ, 1 = ä¿ç•™å­èŠ‚ç‚¹, 2 = ä¸ä¿ç•™å­èŠ‚ç‚¹
            const action = confirm(
                `ç¡®å®šåˆ é™¤ ${appState.selected.size} ä¸ªèŠ‚ç‚¹ï¼Ÿ\n\n` +
                `[ç¡®å®š]  ä¿ç•™å­èŠ‚ç‚¹ï¼ˆå­èŠ‚ç‚¹ä¸Šæµ®ï¼‰\n` +
                `[å–æ¶ˆ]  è¿åŒå­èŠ‚ç‚¹å…¨éƒ¨åˆ é™¤\n` +
                `[Esc]   å–æ¶ˆæ“ä½œ`
            );*/

            // confirm åªæœ‰ true/falseï¼Œæˆ‘ä»¬å€Ÿç”¨å®ƒï¼š
            // ç‚¹ã€Œç¡®å®šã€â†’ true â†’ ä¿ç•™å­èŠ‚ç‚¹
            // ç‚¹ã€Œå–æ¶ˆã€â†’ false â†’ ä¸ä¿ç•™å­èŠ‚ç‚¹
            // æŒ‰ã€ŒEscã€â†’ false â†’ ä¸ä¿ç•™å­èŠ‚ç‚¹
            // ä¸ºäº†çœŸæ­£åŒºåˆ†ï¼Œæ”¹ç”¨ prompt ä¸‰é€‰ä¸€ï¼š
            const code = prompt(
                'è¾“å…¥æ•°å­—é€‰æ‹©åˆ é™¤æ–¹å¼ï¼š\n' +
                '1  ä¿ç•™å­èŠ‚ç‚¹ï¼ˆå­èŠ‚ç‚¹ä¸Šæµ®ï¼‰\n' +
                '2  è¿åŒå­èŠ‚ç‚¹å…¨éƒ¨åˆ é™¤\n' +
                'å…¶ä»–ä»»æ„è¾“å…¥æˆ–ç›´æ¥å–æ¶ˆ â†’ ä¸åšä»»ä½•æ“ä½œ'
            );
            if (code !== '1' && code !== '2') return;   // å–æ¶ˆæˆ–è¯¯è¾“å…¥

            const mode = code === '1' ? 'keep' : 'all';
            commitHistory('delete ' + mode);

            const ids = Array.from(appState.selected);
            ids.forEach(id => {
                // å…ˆå¤„ç†ç©ºç™½èŠ‚ç‚¹
                const oIdx = appState.orphanNodes.findIndex(o => o.id === id);
                if (oIdx > -1) {
                    appState.orphanNodes.splice(oIdx, 1);
                    return;
                }

                // å†å¤„ç†æ ‘èŠ‚ç‚¹
                const r = findById(id);
                if (!r || !r.parent) return;

                if (mode === 'keep') {
                    const idx = r.parent.children.indexOf(r.node);
                    r.parent.children.splice(idx, 1, ...r.node.children);
                } else {
                    r.parent.children = r.parent.children.filter(c => c.id !== id);
                }
            });

            appState.selected.clear();
            renderAll();
        }
        function toggleCollapse(id) {
            const r = findById(id);
            if (!r) return;

            const node = r.node;
            const key = node.id;

            // é¦–æ¬¡è®°å½•å½“å‰è§†é‡
            if (!appState.viewMemory[key]) {
                appState.viewMemory[key] = {};
            }
            const mem = appState.viewMemory[key];

            if (node.collapsed) {
                // ======= å³å°†å±•å¼€ =======
                // 1. å…ˆä¿å­˜ã€ŒæŠ˜å æ—¶ã€è§†é‡
                mem.collapsedTx = appState.tx;
                mem.collapsedTy = appState.ty;
                mem.collapsedScale = appState.scale;

                // 2. å¦‚æœä¹‹å‰å±•å¼€è¿‡ï¼Œæ¢å¤ã€Œå±•å¼€æ—¶ã€è§†é‡
                if (mem.expandedTx !== undefined) {
                    appState.tx = mem.expandedTx;
                    appState.ty = mem.expandedTy;
                    appState.scale = mem.expandedScale;
                } else {
                    // ç¬¬ä¸€æ¬¡å±•å¼€ï¼šç›´æ¥å±…ä¸­åˆ°è¯¥èŠ‚ç‚¹
                    centerOn(key);
                    // æŠŠè¿™æ¬¡è‡ªåŠ¨è®¡ç®—å‡ºçš„è§†é‡è®°ä¸ºã€Œå±•å¼€æ—¶ã€è§†é‡
                    mem.expandedTx = appState.tx;
                    mem.expandedTy = appState.ty;
                    mem.expandedScale = appState.scale;
                }
            } else {
                // ======= å³å°†æŠ˜å  =======
                // 1. ä¿å­˜ã€Œå±•å¼€æ—¶ã€è§†é‡
                mem.expandedTx = appState.tx;
                mem.expandedTy = appState.ty;
                mem.expandedScale = appState.scale;

                // 2. å¦‚æœæœ‰è®°å¿†ï¼Œæ¢å¤ã€ŒæŠ˜å æ—¶ã€è§†é‡
                if (mem.collapsedTx !== undefined) {
                    appState.tx = mem.collapsedTx;
                    appState.ty = mem.collapsedTy;
                    appState.scale = mem.collapsedScale;
                }
            }

            commitHistory('collapse');
            node.collapsed = !node.collapsed;
            renderAll();
            updateView();
            updateMiniMap();
        }
        function promote() {
            const r = findById(currentId()); if (!r || !r.parent) return;
            const gp = findById(r.parent.id);
            if (!gp || !gp.parent) return;
            commitHistory('promote');
            gp.node.children.splice(gp.node.children.indexOf(r.parent) + 1, 0, r.node);
            r.parent.children = r.parent.children.filter(c => c.id !== r.node.id);
            renderAll();
        }
        function editNode(id) {
            const r = findById(id); if (!r) return;
            appState.editing = id;
            const pt = toScreen(r.node.x, r.node.y);
            showPanel(pt.x + 10, pt.y + 10, r.node);
        }
        function updateNodeMeta(node, patch) {
            commitHistory('update meta');
            Object.assign(node.meta, patch);
            // ä¿å­˜å›¾ç‰‡ä½ç½®
            if (patch.imgX !== undefined) node.meta.imgX = patch.imgX;
            if (patch.imgY !== undefined) node.meta.imgY = patch.imgY;
            renderAll();
        }

        /* ---------------------- é¢æ¿ï¼ˆå¤‡æ³¨/é“¾æ¥/å›¾ç‰‡/æ ·å¼/æ ‡ç­¾/ä»»åŠ¡ï¼‰ ---------------------- */
        const panel = $('#panel');
        function showPanel(x, y, node) {
            panel.style.display = 'block';
            panel.style.left = x + 'px'; panel.style.top = y + 'px';
            panel.innerHTML = `
                    <div class="row"><label>æ ‡é¢˜</label><input id="pText" type="text" value="${escapeHtml(node.text || '')}" /></div>
                    <div class="row"><label>çˆ¶èŠ‚ç‚¹</label><button class="btn" id="pChangeParent">ä¿®æ”¹çˆ¶èŠ‚ç‚¹</button> </div>
 

  
                    <div class="row"><label>å›¾æ ‡</label><input id="pIcon" type="text" value="${escapeHtml(node.style?.icon || '')}" placeholder="å¦‚ ğŸš€ æˆ– ğŸ˜€" /></div>
                    <div class="row"><label>é“¾æ¥</label><input id="pLink" type="text" value="${escapeHtml(node.meta?.link || '')}" placeholder="https://..." /></div>
                    <div class="row"><label>å›¾ç‰‡</label><input id="pImg" type="text" value="${escapeHtml(node.meta?.img || '')}" placeholder="å›¾ç‰‡URL æˆ– æ‹–æ‹½ä¸Šä¼ " /></div>
                    <div class="row"><label>å›¾ç‰‡ä½ç½® X</label><input id="pImgX" type="number" value="${node.meta?.imgX || 0}" /></div>
                    <div class="row"><label>å›¾ç‰‡ä½ç½® Y</label><input id="pImgY" type="number" value="${node.meta?.imgY || 0}" /></div>
                    <div class="row"><label>å›¾ç‰‡å®½</label><input id="pImgW" type="number" min="1" value="${node.meta?.imgW || 128}" /></div>
                    <div class="row"><label>å›¾ç‰‡é«˜</label><input id="pImgH" type="number" min="1" value="${node.meta?.imgH || 128}" /></div>
                    <div class="row"><label>å¤‡æ³¨</label><textarea id="pNote" placeholder="æ”¯æŒåŸºç¡€ Markdown">${escapeHtml(node.meta?.note || '')}</textarea></div>
                    <div class="row"><label>ä»»åŠ¡</label>
                    <span class="chip ${node.meta?.task ? 'active' : ''}" id="pTask">${node.meta?.task ? 'å·²å¯ç”¨' : 'æœªå¯ç”¨'}</span>
                    <input type="range" id="pProgress" min="0" max="100" value="${node.meta?.progress || 0}"/>
                     <span class="kbd" id="pProgressLabel">${node.meta?.progress || 0}%</span>
                    </div>
                    <div class="row"><label>ä¼˜å…ˆçº§</label>
                    <select id="pPriority">
                     <option value="0">æ— </option><option value="1">P1</option><option value="2">P2</option><option value="3">P3</option>
                    </select>
                    <span class="chip" id="pTags">${(node.meta?.tags || []).join(',') || '#æ ‡ç­¾â€¦'}</span>
                    </div>
                    <div class="row"><label>æ ·å¼</label>
                    <input type="color" id="pFill" value="${toColor(node.style?.bg) || '#ffffff'}" />
                    <input type="color" id="pBorder" value="${toColor(node.style?.border) || '#ffffff'}" />
                    <button class="btn" id="pClearColor">é‡ç½®é¢œè‰²</button>
                    <button class="btn" id="pClearAll">æ¸…é™¤å†…å®¹</button>
                    </div>
                    <div class="row" style="justify-content:flex-end">
                    <button class="btn" id="pOk">ç¡®å®š</button>
                     <button class="btn" id="pCancel">å–æ¶ˆ</button>
                     </div>
                  `;
            $('#pPriority').value = String(node.meta?.priority || 0);
            $('#pTask').onclick = () => { $('#pTask').classList.toggle('active'); $('#pTask').textContent = $('#pTask').classList.contains('active') ? 'å·²å¯ç”¨' : 'æœªå¯ç”¨'; };
            $('#pProgress').oninput = (e) => $('#pProgressLabel').textContent = e.target.value + '%';
            $('#pTags').onclick = () => {
                const t = prompt('è¾“å…¥æ ‡ç­¾ï¼Œé€—å·åˆ†éš”', (node.meta?.tags || []).join(','));
                if (t != null) $('#pTags').setAttribute('data-tags', t);
            };
            $('#pClearColor').onclick = () => { $('#pFill').value = '#ffffff'; $('#pBorder').value = '#ffffff'; };
            $('#pClearAll').onclick = () => {
                $('#pText').value = ''; $('#pIcon').value = ''; $('#pLink').value = ''; $('#pImg').value = ''; $('#pNote').value = '';
                $('#pTask').classList.remove('active'); $('#pTask').textContent = 'æœªå¯ç”¨';
                $('#pProgress').value = '0'; $('#pProgressLabel').textContent = '0%';
                $('#pPriority').value = '0'; $('#pTags').setAttribute('data-tags', '');
                $('#pFill').value = '#ffffff'; $('#pBorder').value = '#ffffff';
            };
            $('#pOk').onclick = () => {
                commitHistory('edit panel');
                node.text = $('#pText').value;
                node.style.icon = $('#pIcon').value.trim();
                node.meta.link = $('#pLink').value.trim();
                node.meta.img = $('#pImg').value.trim();
                node.meta.imgX = +$('#pImgX').value; // æ›´æ–°å›¾ç‰‡ X åæ ‡
                node.meta.imgY = +$('#pImgY').value; // æ›´æ–°å›¾ç‰‡ Y åæ ‡
                node.meta.imgW = +$('#pImgW').value || 128;
                node.meta.imgH = +$('#pImgH').value || 128;
                node.meta.note = $('#pNote').value;
                node.meta.task = $('#pTask').classList.contains('active');
                node.meta.progress = +$('#pProgress').value;
                node.meta.priority = +$('#pPriority').value;

                const t = $('#pTags').getAttribute('data-tags');
                if (t != null) node.meta.tags = t.split(',').map(s => s.trim()).filter(Boolean); else node.meta.tags = node.meta.tags || [];
                node.style.bg = fromColor($('#pFill').value);
                node.style.border = fromColor($('#pBorder').value);
                hidePanel(); renderAll();

            };
            $('#pCancel').onclick = () => hidePanel();
            $('#pChangeParent').onclick = () => {
                hidePanel();
                setStatus('è¯·ç‚¹å‡»æ–°çš„çˆ¶èŠ‚ç‚¹ï¼ˆæ ‘ç»“æ„ä¸­çš„èŠ‚ç‚¹ï¼‰â€¦');
                appState.awaitingParent = node.id;
            };
        }
        function hidePanel() { panel.style.display = 'none'; appState.editing = null; }
        function escapeHtml(s) { return (s ?? '').toString().replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' }[m])); }
        function toColor(c) { if (!c) return '#ffffff'; const tmp = document.createElement('div'); tmp.style.color = c; document.body.appendChild(tmp); const cs = getComputedStyle(tmp).color; document.body.removeChild(tmp); const m = cs.match(/\d+/g).map(Number); if (!m) return '#ffffff'; return '#' + m.slice(0, 3).map(x => x.toString(16).padStart(2, '0')).join(''); }
        function fromColor(hex) { return hex; }
        function fileToDataURL(file) { return new Promise((res, rej) => { const fr = new FileReader(); fr.onload = () => res(fr.result); fr.onerror = () => rej(fr.error); fr.readAsDataURL(file); }); }

        /* ---------------------- äº¤äº’ï¼šæ‹–æ‹½/ç¼©æ”¾/å¹³ç§»/æ¡†é€‰ ---------------------- */
        const stage = $('#stage'); const world = $('#world'); const nodesG = $('#nodes'); const edgesG = $('#edges');
        let lastMouse = { x: 0, y: 0 };
        function toWorld(x, y) {
            const pt = stage.createSVGPoint(); pt.x = x; pt.y = y;
            const m = world.getCTM().inverse();
            const p = pt.matrixTransform(m);
            return { x: p.x, y: p.y };
        }
        function toScreen(wx, wy) {
            const m = world.getCTM();
            return { x: wx * m.a + m.e, y: wy * m.d + m.f };
        }
        function updateView() {
            world.setAttribute('transform', `translate(${appState.tx},${appState.ty}) scale(${appState.scale})`);
        }
        function onWheel(e) {
            if (e.shiftKey) return;
            e.preventDefault();
            const delta = Math.sign(e.deltaY) * -0.08;
            const old = appState.scale;
            const nx = clamp(old * (1 + delta), .2, 3);
            const mouse = toWorld(e.offsetX, e.offsetY);
            appState.tx = e.offsetX - mouse.x * nx;
            appState.ty = e.offsetY - mouse.y * nx;
            appState.scale = nx;
            updateView(); updateMiniMap();
        }
        let panning = false;
        /* ---------- onMouseDown ---------- */
        function onMouseDown(e) {
            const gid = e.currentTarget.dataset?.id;

            // å¤„äºã€Œç­‰å¾…é€‰æ‹©æ–°çˆ¶èŠ‚ç‚¹ã€çŠ¶æ€
            if (appState.awaitingParent) {
                e.stopPropagation();

                const childId = appState.awaitingParent;
                const newParentId = gid;

                const childR = findById(childId);
                const newParentR = findById(newParentId);

                if (!childR || !newParentR) {
                    setStatus('èŠ‚ç‚¹æœªæ‰¾åˆ°ï¼Œæ“ä½œå–æ¶ˆ');
                    appState.awaitingParent = null;
                    return;
                }

                // ä¸èƒ½é€‰è‡ªå·±
                if (childId === newParentId) {
                    setStatus('ä¸èƒ½é€‰æ‹©è‡ªå·±ä½œä¸ºçˆ¶èŠ‚ç‚¹');
                    appState.awaitingParent = null;
                    return;
                }

                // ä¸èƒ½é€‰è‡ªå·±çš„åä»£
                let isDescendant = false;
                walk(newParentR.node, (n) => {
                    if (n.id === childId) isDescendant = true;
                });
                if (isDescendant) {
                    setStatus('ä¸èƒ½é€‰æ‹©è‡ªå·±çš„åä»£ä½œä¸ºçˆ¶èŠ‚ç‚¹');
                    appState.awaitingParent = null;
                    return;
                }

                commitHistory('change parent');

                // 1. ä»æ—§çˆ¶èŠ‚ç‚¹ä¸­ç§»é™¤
                if (childR.parent) {
                    childR.parent.children = childR.parent.children.filter(c => c.id !== childId);
                }

                // 2. æ·»åŠ åˆ°æ–°çˆ¶èŠ‚ç‚¹çš„ children ä¸­
                newParentR.node.children = newParentR.node.children || [];
                newParentR.node.children.push(childR.node);
                newParentR.node.collapsed = false;

                appState.awaitingParent = null;
                renderAll(); // é‡æ–°å¸ƒå±€ + é‡æ–°ç”»ç®­å¤´
                setStatus('çˆ¶èŠ‚ç‚¹å·²æ›´æ–°');
                return;
            }
            // 1. ç”»å¸ƒä¸ŠæŒ‰ä¸‹ â†’ å¼€å§‹æ¡†é€‰
            if (e.button === 0 && e.target === stage && appState.selectMode === 'box' && (e.ctrlKey || e.metaKey)) {
                e.preventDefault();
                appState.marquee = { x: e.offsetX, y: e.offsetY, w: 0, h: 0 };
                const s = $('#selectionBox');
                s.setAttribute('x', e.offsetX);
                s.setAttribute('y', e.offsetY);
                s.setAttribute('width', 0);
                s.setAttribute('height', 0);
                s.setAttribute('visibility', 'visible');
                return;
            }

            // 2. å·²æœ‰æ¡†æ—¶ï¼Œæ£€æŸ¥æ˜¯å¦ç‚¹å‡»åˆ°æ¡†çŸ©å½¢
            if (appState.marquee) {
                const box = $('#selectionBox');
                const bx = +box.getAttribute('x');
                const by = +box.getAttribute('y');
                const bw = +box.getAttribute('width');
                const bh = +box.getAttribute('height');
                const inBox = e.offsetX >= bx && e.offsetX <= bx + bw &&
                    e.offsetY >= by && e.offsetY <= by + bh;

                // 2-a ç‚¹å‡»èŠ‚ç‚¹ä¸”èŠ‚ç‚¹åœ¨æ¡†å†… â†’ æ•´æ¡†æ‹–åŠ¨
                if (e.target.closest('.node')) {
                    const gid = e.target.closest('.node').dataset.id;
                    const tl = toWorld(bx, by);
                    const br = toWorld(bx + bw, by + bh);
                    const r = findById(gid);
                    if (r && r.node.x >= tl.x && r.node.x <= br.x &&
                        r.node.y >= tl.y && r.node.y <= br.y) {
                        e.preventDefault();
                        appState.marqueeDrag = {
                            mx: e.clientX,
                            my: e.clientY,
                            nodes: []                     // æ”¶é›†æ¡†å†…èŠ‚ç‚¹
                        };
                        $$('#nodes .node').forEach(nEl => {
                            const id = nEl.dataset.id;
                            const nodeObj = findById(id)?.node;
                            if (nodeObj &&
                                nodeObj.x >= tl.x && nodeObj.x <= br.x &&
                                nodeObj.y >= tl.y && nodeObj.y <= br.y) {
                                appState.marqueeDrag.nodes.push(nodeObj);
                            }
                        });
                        return;
                    }
                }

                // 2-b ç‚¹å‡»ç©ºç™½å¤„ â†’ å…³é—­æ¡†é€‰
                if (!inBox && e.target === stage) {
                    closeMarquee();
                    return;
                }
            }


            // 2) æ™®é€šç”»å¸ƒå¹³ç§»
            if (e.button === 0 && e.target === stage) {
                panning = true;
                lastMouse = { x: e.clientX, y: e.clientY };
            }
        }

        /* ---------- onMouseMove ---------- */
        function onMouseMove(e) {
            // 1. æ­£åœ¨æ¡†é€‰
            if (appState.marquee && !appState.marqueeDrag) {
                const s = $('#selectionBox');
                const w = e.offsetX - appState.marquee.x;
                const h = e.offsetY - appState.marquee.y;
                s.setAttribute('width', Math.abs(w));
                s.setAttribute('height', Math.abs(h));
                s.setAttribute('x', w < 0 ? e.offsetX : appState.marquee.x);
                s.setAttribute('y', h < 0 ? e.offsetY : appState.marquee.y);

                // å®æ—¶æ›´æ–°é€‰ä¸­
                const tl = toWorld(+s.getAttribute('x'), +s.getAttribute('y'));
                const br = toWorld(+s.getAttribute('x') + +s.getAttribute('width'),
                    +s.getAttribute('y') + +s.getAttribute('height'));
                appState.selected.clear();
                $$('#nodes .node').forEach(nEl => {
                    const id = nEl.dataset.id;
                    const nodeObj = findById(id)?.node;
                    if (nodeObj &&
                        nodeObj.x - nodeObj.style.w / 2 >= tl.x &&
                        nodeObj.x + nodeObj.style.w / 2 <= br.x &&
                        nodeObj.y - nodeObj.style.h / 2 >= tl.y &&
                        nodeObj.y + nodeObj.style.h / 2 <= br.y) {
                        appState.selected.add(id);
                    }
                });
                renderNodes();
                return;
            }

            // 2. æ­£åœ¨æ¡†æ•´ä½“æ‹–åŠ¨
            if (appState.marqueeDrag) {
                const dx = (e.clientX - appState.marqueeDrag.mx) / appState.scale;
                const dy = (e.clientY - appState.marqueeDrag.my) / appState.scale;
                appState.marqueeDrag.nodes.forEach(n => { n.x += dx; n.y += dy; });
                appState.marqueeDrag.mx = e.clientX;
                appState.marqueeDrag.my = e.clientY;
                renderEdges(); renderNodes(); updateMiniMap();
                return;
            }


            // 2) æ™®é€šç”»å¸ƒå¹³ç§»
            if (panning) {
                appState.tx += e.clientX - lastMouse.x;
                appState.ty += e.clientY - lastMouse.y;
                lastMouse = { x: e.clientX, y: e.clientY };
                updateView();
                updateMiniMap();
            }
        }

        /* ---------- onMouseUp ---------- */
        function onMouseUp() {
            panning = false;
            if (appState.marqueeDrag) {
                commitHistory('move box selection');
                appState.marqueeDrag = null;
            }
        }
        function closeMarquee() {
            $('#selectionBox').setAttribute('visibility', 'hidden');
            appState.selected.clear();
            appState.marquee = null;
            renderNodes();
        }
        
        // é”®ç›˜
        document.addEventListener('keydown', e => {
            if ((e.ctrlKey || e.metaKey) && appState.marquee) closeMarquee();
        });

        // ç”»å¸ƒç©ºç™½å¤„ç‚¹å‡»
        stage.addEventListener('mousedown', e => {
            if (appState.marquee && e.target === stage) closeMarquee();
        });

        let spaceDown = false;
        window.addEventListener('keydown', e => { if (e.code === 'Space') { spaceDown = true; document.body.style.cursor = 'grab'; } });
        window.addEventListener('keyup', e => { if (e.code === 'Space') { spaceDown = false; document.body.style.cursor = ''; } });

        function onNodeMouseDown(e) {
            if (appState.marquee) {
                closeMarquee();
                return;   // ä½ ä¹Ÿå¯ä»¥é€‰æ‹©ç»§ç»­å¤„ç†é€‰ä¸­
            }
            // âœ… ä¼˜å…ˆå¤„ç†ã€Œä¿®æ”¹çˆ¶èŠ‚ç‚¹ã€çŠ¶æ€
            if (appState.awaitingParent) {
                e.stopPropagation(); // å¿…é¡»é˜»æ­¢äº‹ä»¶å†’æ³¡

                const childId = appState.awaitingParent;
                const newParentId = e.currentTarget.getAttribute('data-id');

                const childR = findById(childId);
                const newParentR = findById(newParentId);

                if (!childR || !newParentR) {
                    setStatus('èŠ‚ç‚¹æœªæ‰¾åˆ°ï¼Œæ“ä½œå–æ¶ˆ');
                    appState.awaitingParent = null;
                    return;
                }

                if (childId === newParentId) {
                    setStatus('ä¸èƒ½é€‰æ‹©è‡ªå·±ä½œä¸ºçˆ¶èŠ‚ç‚¹');
                    appState.awaitingParent = null;
                    return;
                }

                // æ£€æŸ¥æ˜¯å¦æ˜¯åä»£
                let isDescendant = false;
                walk(newParentR.node, (n) => {
                    if (n.id === childId) isDescendant = true;
                });
                if (isDescendant) {
                    setStatus('ä¸èƒ½é€‰æ‹©è‡ªå·±çš„åä»£ä½œä¸ºçˆ¶èŠ‚ç‚¹');
                    appState.awaitingParent = null;
                    return;
                }

                commitHistory('change parent');

                // 1. ä»æ—§çˆ¶èŠ‚ç‚¹ç§»é™¤
                if (childR.parent) {
                    childR.parent.children = childR.parent.children.filter(c => c.id !== childId);
                }

                // 2. æ·»åŠ åˆ°æ–°çˆ¶èŠ‚ç‚¹
                newParentR.node.children = newParentR.node.children || [];
                newParentR.node.children.push(childR.node);
                newParentR.node.collapsed = false;

                appState.awaitingParent = null;
                renderAll();
                setStatus('çˆ¶èŠ‚ç‚¹å·²æ›´æ–°');
                return;
            }

            if (appState.lockNodes) return;   // âœ… é”å®šçŠ¶æ€ä¸‹ç›´æ¥å¿½ç•¥èŠ‚ç‚¹äº‹ä»¶
            e.stopPropagation();
            const gid = e.currentTarget.getAttribute('data-id');
            const worldPos = toWorld(e.clientX - stage.getBoundingClientRect().left, e.clientY - stage.getBoundingClientRect().top);
            let last = worldPos;
            if (e.shiftKey) toggleSelect(gid); else selectOnly(gid);
            // æ‹–æ‹½èŠ‚ç‚¹ï¼šæ·»åŠ åç§»ï¼ˆåœ¨è‡ªåŠ¨å¸ƒå±€åŸºç¡€ä¸Šå…è®¸äººå·¥å¾®è°ƒï¼‰
            appState.dragging = { id: gid, start: last };
            window.addEventListener('mousemove', dragMove);
            window.addEventListener('mouseup', dragEnd, { once: true });

            // åŒå‡»äº‹ä»¶
            if (e.detail === 2) { // detail === 2 è¡¨ç¤ºåŒå‡»
                e.preventDefault();
                editNode(gid); // è°ƒç”¨ editNode å‡½æ•°æ‰“å¼€æ ·å¼é¢æ¿
            }
        }
        function dragMove(e) {
            const wp = toWorld(e.clientX - stage.getBoundingClientRect().left, e.clientY - stage.getBoundingClientRect().top);
            const d = { x: wp.x - appState.dragging.start.x, y: wp.y - appState.dragging.start.y };
            appState.dragging.start = wp;
            const ids = Array.from(appState.selected);
            ids.forEach(id => {
                const r = findById(id).node;
                r.x += d.x; r.y += d.y;
            });
            renderEdges(); renderNodes(); updateMiniMap();
        }
        function dragEnd() {
            window.removeEventListener('mousemove', dragMove);
            resolveOverlaps(); // âœ… æ–°å¢
            commitHistory('drag nodes');
            appState.dragging = null;
            /*const ids = Array.from(appState.selected);
            ids.forEach(id => {
                const r = findById(id);
                if (r) r.node.__manual = true;
            });*/
            renderAll();
        }

        /* ---------------------- æœç´¢ ---------------------- */
        $('#search').addEventListener('input', (e) => {
            const v = e.target.value.trim();
            appState.searchRe = v ? new RegExp(v, 'i') : null;
            renderNodes();
        });

        /* ---------------------- è¿·ä½ åœ°å›¾ ---------------------- */
        function worldBBox() {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            walk(model, (n) => {
                minX = Math.min(minX, n.x - n.style.w / 2); minY = Math.min(minY, n.y - n.style.h / 2);
                maxX = Math.max(maxX, n.x + n.style.w / 2); maxY = Math.max(maxY, n.y + n.style.h / 2);
            });
            if (!isFinite(minX)) return { x: -100, y: -100, w: 200, h: 200 };
            return { x: minX - 120, y: minY - 120, w: (maxX - minX) + 240, h: (maxY - minY) + 240 };
        }
        function updateMiniMap() {
            const mini = $('#miniSvg'); const mw = $('#miniWorld'); const vp = $('#miniViewport');
            mw.innerHTML = '';
            const bb = worldBBox();
            const sx = mini.clientWidth / bb.w;
            const sy = mini.clientHeight / bb.h;
            const s = Math.min(sx, sy);
            // èŠ‚ç‚¹ç‚¹ä½
            walk(model, (n) => {
                const cx = (n.x - bb.x) * s, cy = (n.y - bb.y) * s;
                const dot = document.createElementNS(mini.namespaceURI, 'rect');
                dot.setAttribute('x', cx - 2); dot.setAttribute('y', cy - 2); dot.setAttribute('width', 4); dot.setAttribute('height', 4);
                dot.setAttribute('fill', 'var(--accent)');
                mw.appendChild(dot);
            });
            // è§†å£
            const view = {
                x: (-appState.tx - bb.x * appState.scale) * s / appState.scale,
                y: (-appState.ty - bb.y * appState.scale) * s / appState.scale,
                w: (stage.clientWidth) * s / appState.scale,
                h: (stage.clientHeight) * s / appState.scale,
            };
            vp.setAttribute('x', view.x); vp.setAttribute('y', view.y);
            vp.setAttribute('width', view.w); vp.setAttribute('height', view.h);
        }

        /* ---------------------- å¯¼å…¥å¯¼å‡º ---------------------- */
        $('#btnSave').onclick = () => {
            const blob = new Blob([JSON.stringify(model, null, 2)], { type: 'application/json' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `mindflow-${Date.now()}.json`; a.click();
        };
        $('#btnOpen').onclick = () => $('#fileOpen').click();
        $('#fileOpen').addEventListener('change', async (e) => {
            const file = e.target.files[0]; if (!file) return;
            const txt = await file.text();
            try {
                const data = JSON.parse(txt);
                commitHistory('open');
                model = data; appState.selected.clear(); renderAll(); setStatus('å¯¼å…¥å®Œæˆ');
            } catch (err) { alert('JSON æ— æ³•è§£æï¼š' + err.message); }
        });
        $('#btnSvg').onclick = () => {
            const clone = $('#stage').cloneNode(true);
            clone.querySelector('#selectionBox')?.setAttribute('visibility', 'hidden');
            const s = new XMLSerializer().serializeToString(clone);
            const blob = new Blob([s], { type: 'image/svg+xml' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `mindflow-${Date.now()}.svg`; a.click();
        };
        $('#btnPng').onclick = async () => {
            const svg = $('#stage');
            const s = new XMLSerializer().serializeToString(svg);
            const img = new Image();
            const bb = worldBBox();
            const pad = 60;
            const scale = 2;
            const w = Math.max(800, (bb.w + pad * 2) * scale);
            const h = Math.max(600, (bb.h + pad * 2) * scale);
            const canvas = document.createElement('canvas'); canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext('2d');
            const bg = getComputedStyle(document.body).getPropertyValue('--bg').trim();
            ctx.fillStyle = bg; ctx.fillRect(0, 0, w, h);
            const blob = new Blob([s], { type: 'image/svg+xml;charset=utf-8' }); const url = URL.createObjectURL(blob);
            await new Promise(res => { img.onload = res; img.src = url; });
            const vw = svg.clientWidth, vh = svg.clientHeight;
            ctx.drawImage(img, (w - vw * scale) / 2, (h - vh * scale) / 2, vw * scale, vh * scale);
            const a = document.createElement('a'); a.href = canvas.toDataURL('image/png'); a.download = `mindflow-${Date.now()}.png`; a.click();
            URL.revokeObjectURL(url);
        };

        /* ---------------------- é”®ç›˜ä¸æŒ‰é’® ---------------------- */
        document.addEventListener('keydown', (e) => {
            if (
                panel.style.display === 'block' ||
                $('#libraryOverlay').style.display === 'flex' ||
                $('#shortcutsModal').style.display === 'flex'
            ) {
                return;
            }
            const meta = e.metaKey || e.ctrlKey;
            if (e.key === 'Enter' && !e.shiftKey) { addSibling(); e.preventDefault(); }
            if (e.key === 'Enter' && e.shiftKey) { addSibling(); e.preventDefault(); }
            if (e.key === 'Tab' && !e.shiftKey) { addChild(); e.preventDefault(); }
            if (e.key === 'Tab' && e.shiftKey) { promote(); e.preventDefault(); }
            if (e.key === 'F') { addParent(); e.preventDefault(); }
            if (e.key === 'f') { addParent(); e.preventDefault(); }
            if (e.key === '/' && !e.shiftKey) { removeSelected(); e.preventDefault(); } // ä¿®æ”¹ä¸ºä½¿ç”¨ / é”®åˆ é™¤èŠ‚ç‚¹
            if (e.key === ' ' && !appState.editing) { // æŠ˜å 
                toggleCollapse(currentId()); e.preventDefault();
            }
            if (meta && e.key.toLowerCase() === 'z') { if (e.shiftKey) redo(); else undo(); e.preventDefault(); }
            if (meta && e.key.toLowerCase() === 'f') { $('#search').focus(); $('#search').select(); e.preventDefault(); }
            if (e.key === '+') { onWheel({ preventDefault: () => { }, deltaY: -100, offsetX: stage.clientWidth / 2, offsetY: stage.clientHeight / 2 }); }
            if (e.key === '-') { onWheel({ preventDefault: () => { }, deltaY: 100, offsetX: stage.clientWidth / 2, offsetY: stage.clientHeight / 2 }); }
            if (e.key === '1') { appState.layout = 'right'; renderAll(); }
            if (e.key === '2') { appState.layout = 'both'; renderAll(); }
            if (e.key === '3') { appState.layout = 'radial'; renderAll(); }
            if (e.key === '.') {
                appState.lockNodes = !appState.lockNodes;
                setStatus(appState.lockNodes ? 'èŠ‚ç‚¹å·²é”å®šï¼ˆæŒ‰ . æˆ– Esc è§£é”ï¼‰' : 'èŠ‚ç‚¹å·²è§£é”');
                return;
            }
            if (e.key === 'D' && e.shiftKey) {
                appState.deleteMode = appState.deleteMode === 'keep' ? 'all' : 'keep';
                setStatus('åˆ é™¤æ¨¡å¼ï¼š' + (appState.deleteMode === 'keep' ? 'ä¿ç•™å­èŠ‚ç‚¹' : 'è¿åŒå­èŠ‚ç‚¹'));
            }
            if (e.key === 'Escape') {
                if (appState.lockNodes) {
                    appState.lockNodes = false;
                    setStatus('èŠ‚ç‚¹å·²è§£é”');
                }
            }
            // R é”®ï¼šé‡ç½®æ‰€æœ‰æ‰‹åŠ¨å¸ƒå±€ â†’ æ¢å¤é»˜è®¤åæ ‡
            // åœ¨ document.addEventListener('keydown', (e) => { ... }) ä¸­ï¼Œæ‰¾åˆ°ä»¥ä¸‹éƒ¨åˆ†å¹¶æ›¿æ¢ï¼š

            // æ‰¾åˆ°ä½ çš„ document.addEventListener('keydown', (e) => { ... }) å‡½æ•°ï¼Œæ›¿æ¢ä»¥ä¸‹éƒ¨åˆ†ï¼š

            // âœ… Shift + Rï¼šé‡ç½®æ‰€æœ‰æ‰‹åŠ¨å¸ƒå±€èŠ‚ç‚¹
            if (e.shiftKey && (e.key === 'R' || e.key === 'r')) {
                e.preventDefault(); // é˜»æ­¢é»˜è®¤è¡Œä¸º
                const allNodes = [];
                walk(model, (n) => {
                    if (n.__manual) allNodes.push(n);
                });

                if (allNodes.length === 0) {
                    setStatus('æ²¡æœ‰èŠ‚ç‚¹éœ€è¦é‡ç½®');
                    return;
                }

                if (!confirm(`å°†é‡ç½® ${allNodes.length} ä¸ªèŠ‚ç‚¹çš„ä½ç½®ï¼Œç¡®å®šå—ï¼Ÿ`)) return;

                allNodes.forEach(n => {
                    n.__manual = false; // æ¸…é™¤æ‰‹åŠ¨æ ‡è®°
                });

                commitHistory('reset all manual layout');
                renderAll();
                setStatus('å·²æ¢å¤é»˜è®¤å¸ƒå±€');
                return; // å…³é”®ï¼šé˜»æ­¢ç»§ç»­æ‰§è¡Œä¸‹é¢çš„ R é”®åˆ¤æ–­
            }

            // âœ… æ™®é€š Rï¼šé‡ç½®é€‰ä¸­çš„èŠ‚ç‚¹
            if (!e.shiftKey && (e.key === 'R' || e.key === 'r')) {
                e.preventDefault();
                const ids = Array.from(appState.selected);
                if (ids.length === 0) {
                    setStatus('è¯·å…ˆé€‰ä¸­èŠ‚ç‚¹');
                    return;
                }

                if (!confirm(`é‡ç½® ${ids.length} ä¸ªèŠ‚ç‚¹åˆ°é»˜è®¤ä½ç½®ï¼Ÿ`)) return;

                ids.forEach(id => {
                    const r = findById(id);
                    if (r) {
                        r.node.__manual = false; // æ¸…é™¤æ‰‹åŠ¨æ ‡è®°
                    }
                });

                commitHistory('reset selected nodes');
                renderAll();
                setStatus('å·²é‡ç½®é€‰ä¸­èŠ‚ç‚¹');
                return;
            }
            
        });
        $('#btnAddSibling').onclick = addSibling;
        $('#btnAddParent').onclick = addParent;
        $('#btnAddChild').onclick = addChild;
        $('#btnDelete').onclick = removeSelected;
        $('#btnLayoutRight').onclick = () => { appState.layout = 'right'; renderAll(); };
        $('#btnLayoutBoth').onclick = () => { appState.layout = 'both'; renderAll(); };
        $('#btnLayoutRadial').onclick = () => { appState.layout = 'radial'; renderAll(); };
        $('#btnUndo').onclick = undo; $('#btnRedo').onclick = redo;
        $('#btnFit').onclick = () => fitView();
        $('#btnCenter').onclick = () => centerOn(model.id);
        $('#btnTheme').onclick = () => {
            const cur = document.body.getAttribute('data-theme'); document.body.setAttribute('data-theme', cur === 'dark' ? 'light' : 'dark');
        };
        $('#btnNew').onclick = () => {
            if (!confirm('æ–°å»ºä¼šä¸¢å¤±å½“å‰æœªä¿å­˜ä¿®æ”¹ï¼Œç»§ç»­ï¼Ÿ')) return;
            commitHistory('new');
            model = { id: 'root', text: 'ä¸­å¿ƒä¸»é¢˜', style: {}, meta: { tags: [] }, children: [] };
            appState.selected.clear(); appState.tx = stage.clientWidth / 2; appState.ty = stage.clientHeight / 2; appState.scale = 1;
            appState.currentMapId = null;
            renderAll();
        };
        

        /* library buttons */
        $('#btnLibrary').onclick = () => showLibrary();
        $('#libCloseBtn').onclick = () => hideLibrary();
        $('#libNewBtn').onclick = () => { const name = prompt('å¯¼å›¾åç§°ï¼š', 'æ–°çš„å¯¼å›¾'); if (name != null) { const id = createMapWithModel(name, model); openMap(id); } };
        $('#libImportBtn').onclick = () => $('#libFile').click();
        $('#libFile').addEventListener('change', async (e) => {
            const f = e.target.files[0]; if (!f) return;
            const txt = await f.text();
            try {
                const data = JSON.parse(txt);
                const name = prompt('ä¸ºå¯¼å…¥çš„å¯¼å›¾å‘½åï¼š', data.text || 'å¯¼å…¥å¯¼å›¾');
                const id = createMapWithModel(name, data);
                renderLibrary();
                setStatus('å¯¼å…¥åˆ°åº“ï¼š' + name);
            } catch (err) { alert('JSON æ— æ³•è§£æï¼š' + err.message); }
        });
        $('#btnSaveMap').onclick = () => saveCurrentMap();
      
       
        /* ---------------------- è§†å›¾æ§åˆ¶ ---------------------- */
        function fitView() {
            const bb = worldBBox();
            const pad = 100;
            const sx = (stage.clientWidth - pad) / bb.w;
            const sy = (stage.clientHeight - pad) / bb.h;
            const s = clamp(Math.min(sx, sy), .2, 3);
            appState.scale = s;
            appState.tx = (stage.clientWidth - (bb.x * s) - (bb.w * s)) / 2 - (bb.x * s - 0);
            appState.ty = (stage.clientHeight - (bb.y * s) - (bb.h * s)) / 2 - (bb.y * s - 0);
            updateView(); updateMiniMap();
        }
        function centerOn(id) {
            const r = findById(id); if (!r) return;
            const scr = { x: stage.clientWidth / 2, y: stage.clientHeight / 2 };
            const s = appState.scale;
            appState.tx = scr.x - r.node.x * s;
            appState.ty = scr.y - r.node.y * s;
            updateView(); updateMiniMap();
        }
        //-----------------------------------------------
        function addParent() {
            const cur = findById(currentId());
            if (!cur || !cur.parent) return;

            commitHistory('add parent');

            // 1. å…ˆæŠŠå½“å‰èŠ‚ç‚¹åŠå…¶å…¨éƒ¨åä»£æ•´ä½“å³ç§» 140pxï¼Œé¿å…é‡å 
            const offset = 140;
            (function shiftX(node) {
                node.x += offset;
                (node.children || []).forEach(shiftX);
            })(cur.node);

            // 2. åˆ›å»ºæ–°çš„çˆ¶èŠ‚ç‚¹ï¼Œæ”¾åœ¨åŸä½ç½®
            const newParent = {
                id: rndId(),
                text: 'çˆ¶çº§èŠ‚ç‚¹',
                children: [cur.node],
                collapsed: false,
                style: {},
                meta: { tags: [] },
                x: cur.node.x - offset, // åŸä½ç½®
                y: cur.node.y
            };
            const m = measureSvg(newParent.text);
            newParent.style.w = m.w;
            newParent.style.h = m.h;

            // 3. æ›¿æ¢åˆ°åŸçˆ¶èŠ‚ç‚¹çš„ children ä¸­
            const idx = cur.parent.children.indexOf(cur.node);
            cur.parent.children.splice(idx, 1, newParent);

            
            selectOnly(newParent.id);
            renderAll();
            resolveOverlaps();
            renderAll();
        } //clearManualUpwards2(currentId());// âœ… æ¸…é™¤æ‰‹åŠ¨æ ‡è®°clearManualUpwards2(currentId());
        /*function addParent() {
            const curIds = Array.from(appState.selected);
            if (curIds.length === 0) {
                setStatus('è¯·å…ˆé€‰ä¸­è¦æŒ‚æ¥çš„èŠ‚ç‚¹');
                return;
            }

            // 1. è¿‡æ»¤å‡ºçœŸæ­£çš„ç©ºç™½èŠ‚ç‚¹
            const orphanIds = curIds.filter(id =>
                appState.orphanNodes.some(o => o.id === id)
            );
            if (orphanIds.length === 0) {
                setStatus('é€‰ä¸­çš„èŠ‚ç‚¹å·²åœ¨æ ‘ä¸­ï¼Œæ— éœ€å†ç»‘å®šçˆ¶çº§');
                return;
            }

            // 2. æ”¶é›†æ‰€æœ‰å¯é€‰çˆ¶èŠ‚ç‚¹ï¼ˆæ ‘èŠ‚ç‚¹ + ç©ºç™½èŠ‚ç‚¹ï¼Œæ’é™¤è‡ªå·±ï¼‰
            const candidates = [];
            // â‘  æ ‘èŠ‚ç‚¹
            walk(model, n => candidates.push({ id: n.id, text: n.text }));
            // â‘¡ ç©ºç™½èŠ‚ç‚¹
            appState.orphanNodes.forEach(o => {
                if (!orphanIds.includes(o.id)) {
                    candidates.push({ id: o.id, text: o.text });
                }
            });

            if (candidates.length === 0) {
                setStatus('æ²¡æœ‰å¯ç”¨çš„çˆ¶èŠ‚ç‚¹');
                return;
            }

            // 3. å¼¹åˆ—è¡¨è®©ç”¨æˆ·é€‰æ‹©ï¼ˆcancel è¿”å› nullï¼‰
            const choices = candidates.map((c, idx) => `${idx + 1}. ${c.text} (${c.id})`).join('\n');
            const input = prompt(
                `è¯·é€‰æ‹©è¦ä½œä¸ºçˆ¶çº§çš„èŠ‚ç‚¹ï¼ˆè¾“å…¥åºå·å³å¯ï¼‰ï¼š\n\n${choices}\n\nè¾“å…¥ 0 æˆ–å–æ¶ˆå¯æ”¾å¼ƒæ“ä½œ`
            );
            if (!input) return;                // å–æ¶ˆ
            const idx = parseInt(input, 10) - 1;
            if (isNaN(idx) || idx < 0 || idx >= candidates.length) return;

            const parentId = candidates[idx].id;
            const parent = findById(parentId);
            if (!parent) return;

            // 4. çœŸæ­£ç»‘å®š
            commitHistory('bind parent');
            orphanIds.forEach(id => {
                const r = findById(id);
                if (!r) return;

                // ä»ç©ºç™½åˆ—è¡¨ç§»é™¤
                const oIdx = appState.orphanNodes.findIndex(o => o.id === id);
                if (oIdx > -1) appState.orphanNodes.splice(oIdx, 1);

                // æŒ‚åˆ°çˆ¶èŠ‚ç‚¹
                parent.node.children = parent.node.children || [];
                parent.node.children.push(r.node);
                parent.node.collapsed = false;
                clearManualUpwards(id);
            });

            renderAll();
            setStatus(`å·²å°† ${orphanIds.length} ä¸ªèŠ‚ç‚¹ç»‘å®šåˆ° ${parent.node.text}`);
        }*/

        /* ---------------------- äº‹ä»¶ç»‘å®š ---------------------- */
        stage.addEventListener('wheel', onWheel, { passive: false });
        stage.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);

        /* ---------------------- åº•éƒ¨ä¿¡æ¯ ---------------------- */
        function updateFooter() {
            let nodes = 0, edges = 0;
            walk(model, () => nodes++, (p) => edges++);
            $('#footMeta').textContent = `èŠ‚ç‚¹: ${nodes} Â· è¿çº¿: ${Math.max(0, nodes - 1)} Â· ${nowStr()}`;
            if (appState.lockNodes) $('#footMeta').textContent += ' Â· èŠ‚ç‚¹å·²é”å®š';
        }

        /* ---------------------- è¾…åŠ© ---------------------- */
        function toMarkdownHtml(md) {
            return md
                .replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
                .replace(/\*\*(.+?)\*\*/g, '<b>$1</b>')
                .replace(/\*(.+?)\*/g, '<i>$1</i>')
                .replace(/__(.+?)__/g, '<u>$1</u>')
                .replace(/`(.+?)`/g, '<code>$1</code>')
                .replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2" target="_blank">$1</a>');
        }

        /* ---------------------- Library UI ---------------------- */
        function showLibrary() {
            $('#libraryOverlay').style.display = 'flex';
            renderLibrary();
        }
        function hideLibrary() {
            $('#libraryOverlay').style.display = 'none';
        }

        /* ---------------------- åˆå§‹åŒ– ---------------------- */
        function bootstrap() {
            commitHistory('init');
            // åˆå§‹å®šä½å±…ä¸­
            appState.scale = 1; appState.tx = stage.clientWidth / 2; appState.ty = stage.clientHeight / 2;
            renderAll();
            setStatus('å°±ç»ª');
            // å¦‚æœæœ¬åœ°æ²¡æœ‰å¯¼å›¾ï¼Œå…ˆåˆ›å»ºä¸€ä¸ªç¤ºä¾‹å¯¼å›¾å¹¶æ‰“å¼€åº“
            const lib = loadLibrary();
            if (!lib.length) {
                createMapWithModel('ç¤ºä¾‹å¯¼å›¾', model);
            }
            // æ˜¾ç¤ºåº“ä½œä¸ºä¸»ç•Œé¢å…¥å£ï¼ˆç”¨æˆ·å¯ä»¥é€‰æ‹©å¯¼å›¾æˆ–ç»§ç»­å½“å‰ï¼‰
            showLibrary();
            /* ç›‘å¬ç²˜è´´äº‹ä»¶ */
            window.addEventListener('paste', async (e) => {
                const items = e.clipboardData?.items;
                if (!items) return;

                for (const item of items) {
                    if (item.type.startsWith('image/')) {
                        e.preventDefault();
                        const file = item.getAsFile();
                        if (!file) continue;

                        const dataUrl = await fileToDataURL(file);
                        const id = currentId();
                        const r = findById(id);
                        if (!r) continue;

                        commitHistory('paste image');
                        r.node.meta.img = dataUrl;
                        r.node.meta.imgX = r.node.x + r.node.style.w; // é»˜è®¤æ”¾åœ¨èŠ‚ç‚¹å³ä¾§
                        r.node.meta.imgY = r.node.y;
                        renderAll();
                        setStatus('å›¾ç‰‡å·²ç²˜è´´åˆ°èŠ‚ç‚¹');
                        break;
                    }
                }

            });
            /* æ–¹æ³•äºŒï¼šShift + æ»šè½®ç¼©æ”¾å½“å‰èŠ‚ç‚¹å›¾ç‰‡ */
            window.addEventListener('wheel', (e) => {
                if (!e.shiftKey) return;                // ä»…æŒ‰ä½ Shift æ—¶ç”Ÿæ•ˆ
                const id = currentId();                 // å½“å‰é€‰ä¸­çš„èŠ‚ç‚¹
                if (!id) return;
                const r = findById(id);
                if (!r || !r.node.meta.img) return;     // æ²¡æœ‰å›¾ç‰‡å¿½ç•¥

                e.preventDefault();
                const scaleFactor = e.deltaY < 0 ? 1.1 : 0.9; // å‘ä¸Šæ”¾å¤§ï¼Œå‘ä¸‹ç¼©å°
                let w = r.node.meta.imgW ?? 128;
                let h = r.node.meta.imgH ?? 128;
                w = Math.round(w * scaleFactor);
                h = Math.round(h * scaleFactor);
                w = Math.max(16, Math.min(800, w));     // é™åˆ¶èŒƒå›´
                h = Math.max(16, Math.min(800, h));

                commitHistory('resize image');
                r.node.meta.imgW = w;
                r.node.meta.imgH = h;
                renderAll();
                setStatus(`å›¾ç‰‡å°ºå¯¸ ${w} Ã— ${h}`);
            }, { passive: false });
            

            
            window.addEventListener('beforeunload', (e) => {
                // ä½ å¯ä»¥æ ¹æ®å®é™…éœ€æ±‚åˆ¤æ–­æ˜¯å¦æœ‰æœªä¿å­˜å†…å®¹
                const hasUnsaved = true; // ç¤ºä¾‹ï¼šå§‹ç»ˆæç¤º
                if (hasUnsaved) {
                    e.preventDefault();
                    e.returnValue = 'å¯¼å›¾å°šæœªä¿å­˜ï¼Œç¡®å®šè¦ç¦»å¼€å—ï¼Ÿ';
                }
            });
            window.addEventListener('keydown', e => {
                if (e.key === 'Escape') {
                    appState.imageDragging = null;
                }
            });
            $('#btnSelMode').onclick = () => {
                appState.selectMode = appState.selectMode === 'point' ? 'box' : 'point';
                $('#btnSelMode').textContent = appState.selectMode === 'point' ? 'ç‚¹é€‰æ¨¡å¼' : 'æ¡†é€‰æ¨¡å¼';
                setStatus('å·²åˆ‡æ¢ä¸º ' + $('#btnSelMode').textContent);
            };
        }
        function resetNodePosition(id) {
            const r = findById(id);
            if (!r) return;
            r.node.__manual = false;   // âœ… å»æ‰æ‰‹åŠ¨æ ‡è®°
            commitHistory('reset layout');
            renderAll();
        }
        function clearManualUpwards(id) {
            let current = findById(id);
            while (current) {
                delete current.node.__manual;
                current = current.parent ? findById(current.parent.id) : null;
            }
        }
        function clearManualUpwards2(id) {
            const r = findById(id);
            if (!r || !r.parent) return;
            delete r.node.__manual;
            clearManualUpwards(r.parent.id);   // é€’å½’çˆ¶èŠ‚ç‚¹
        }
        function addOrphanNode() {
            const node = {
                id: rndId(),
                text: 'ç©ºç™½èŠ‚ç‚¹',
                children: [],
                collapsed: false,
                style: {},
                meta: { tags: [] },
                __orphan: true
            };
            // æ”¾åˆ°ç”»å¸ƒä¸­å¿ƒ
            node.x = (stage.clientWidth / 2 - appState.tx) / appState.scale;
            node.y = (stage.clientHeight / 2 - appState.ty) / appState.scale;

            /* ===== æ–°å¢ï¼šè¡¥ä¸Šå®½é«˜ï¼Œé¿å… NaN ===== */
            const m = measureSvg(node.text);
            node.style.w = m.w;
            node.style.h = m.h;

            appState.orphanNodes.push(node);
            commitHistory('add orphan');
            renderAll();
        }
        window.addEventListener('resize', () => { updateMiniMap(); });
       

        bootstrap();
        $('#btnOrphan').onclick = addOrphanNode;
        /* ===== ç‚¹å‡»ç”»å¸ƒç©ºç™½å¤„å…³é—­æµ®åŠ¨é¢æ¿ ===== */
        stage.addEventListener('mousedown', e => {
            // å¦‚æœç‚¹çš„æ˜¯ç”»å¸ƒæœ¬èº«ï¼ˆä¸æ˜¯èŠ‚ç‚¹ã€ä¸æ˜¯æŒ‰é’®ï¼‰ä¸”é¢æ¿å·²æ‰“å¼€
            if (e.target === stage && panel.style.display === 'block') {
                
                document.getElementById('pOk')?.click();
                hidePanel();
            }
        });
        /* ===== æç®€æ–¹æ¡ˆï¼šCtrl+ç‚¹å‡»èŠ‚ç‚¹è·³è½¬é“¾æ¥ ===== 
        stage.addEventListener('click', function (e) {
            // æ‰¾åˆ°å®é™…èŠ‚ç‚¹
            let el = e.target;
            while (el && !el.classList.contains('node')) el = el.parentElement;
            if (!el) return;

            if (e.ctrlKey || e.metaKey) {
                const id = el.dataset.id;
                const r = findById(id);
                if (!r) return;

                const url = r.node.meta?.link || '';
                if (url) {
                    window.open(url, '_blank');
                } else {
                    console.log('èŠ‚ç‚¹é“¾æ¥ä¸ºç©º');
                }
                e.stopPropagation();   // é˜²æ­¢å…¶å®ƒäº‹ä»¶è§¦å‘
            }
        });*/
        /* ===== ä¿®å¤ NaN / undefined æŠ¥é”™ ===== */
        (() => {
            // 1. å…œåº• measureSvg
            const oldMeasure = measureSvg;
            window.measureSvg = (str, metaLine) => {
                const res = oldMeasure(str, metaLine);
                return { w: Math.max(res.w || 80, 80), h: Math.max(res.h || 28, 28) };
            };

            // 2. å…œåº• autoLayout é‡Œçš„ place
            const oldPlace = window.place || function () { };
            if (window.place) return;  // å·²å…œåº•åˆ™è·³è¿‡
        })();
        // åˆ¤æ–­ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯å¦é‡å 
        function isOverlap(a, b, tolerance = 4) {
            const ax = a.x - a.style.w / 2;
            const ay = a.y - a.style.h / 2;
            const bx = b.x - b.style.w / 2;
            const by = b.y - b.style.h / 2;

            return !(ax + a.style.w + tolerance < bx ||
                bx + b.style.w + tolerance < ax ||
                ay + a.style.h + tolerance < by ||
                by + b.style.h + tolerance < ay);
        }
        function resolveOverlaps() {
            const nodes = [];
            walk(model, n => nodes.push(n));
            appState.orphanNodes.forEach(n => nodes.push(n));

            let moved = true;
            let maxIter = 30; // é˜²æ­¢æ­»å¾ªç¯
            while (moved && maxIter-- > 0) {
                moved = false;
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const a = nodes[i];
                        const b = nodes[j];
                        if (!isOverlap(a, b)) continue;

                        // è®¡ç®—æ¨å¼€è·ç¦»
                        const dx = (a.x - b.x);
                        const dy = (a.y - b.y);
                        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                        const overlapX = (a.style.w + b.style.w) / 2 - Math.abs(dx);
                        const overlapY = (a.style.h + b.style.h) / 2 - Math.abs(dy);

                        const pushFactor = 1.2; // æ¨å¼€åŠ›åº¦
                        let pushX = 0, pushY = 0;
                        if (overlapX < overlapY) {
                            pushX = Math.sign(dx) * (overlapX / 2 + 6) * pushFactor;
                        } else {
                            pushY = Math.sign(dy) * (overlapY / 2 + 6) * pushFactor;
                        }

                        // æ¨åŠ¨ä¸¤ä¸ªèŠ‚ç‚¹
                        a.x += pushX;
                        a.y += pushY;
                        b.x -= pushX;
                        b.y -= pushY;

                        // æ ‡è®°ä¸ºå·²ç§»åŠ¨
                        moved = true;
                    }
                }
            }
        }
        document.getElementById('btnAISummary').onclick = async () => {
            const text = document.getElementById('aiInput').value;
            if (!text.trim()) return alert('è¯·è¾“å…¥å†…å®¹');

            // è°ƒç”¨ä½ çš„ AI æ¥å£ï¼ˆç¤ºä¾‹ç”¨ fetchï¼‰
            const res = await fetch('/api/ai-summary', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text })
            });

            const json = await res.json();

            if (json && json.id && json.text) {
                // å¯¼å…¥åˆ° MindFlow
                commitHistory('AI å¯¼å…¥å¯¼å›¾');
                model = json;
                appState.selected.clear();
                renderAll();
                setStatus('AI å¯¼å›¾å·²ç”Ÿæˆï¼');
            } else {
                alert('AI è¿”å›æ ¼å¼é”™è¯¯');
            }
        };
        /* ===== æ–°å¢ï¼šåˆå¹¶å¯¼å…¥åŠŸèƒ½ ===== */
        /* âœ… ä¿®æ­£ç‰ˆï¼šåˆå¹¶å¯¼å…¥ JSONï¼ˆé¿å…æ ¹å†²çª + è‡ªåŠ¨å³ç§»ï¼‰ */
        function mergeImportJSON() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                try {
                    const text = await file.text();
                    const subModel = JSON.parse(text);

                    const targetId = currentId();
                    const parent = findById(targetId);
                    if (!parent) return alert('è¯·å…ˆé€‰ä¸­ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºçˆ¶èŠ‚ç‚¹');

                    commitHistory('merge import JSON');

                    // æ·±æ‹·è´å­å›¾æ‰€æœ‰ children
                    const childrenToAdd = JSON.parse(JSON.stringify(subModel.children || []));

                    // è®¡ç®—åç§»ï¼šå½“å‰èŠ‚ç‚¹å³ä¾§ 200px
                    const offsetX = 200;
                    const baseY = parent.node.y;

                    // é€’å½’åç§»æ‰€æœ‰å­èŠ‚ç‚¹åæ ‡
                    const applyOffset = (nodes, dx, dyBase) => {
                        nodes.forEach(n => {
                            n.x = (n.x || 0) + dx;
                            n.y = (n.y || 0) + dyBase;
                            if (n.children) applyOffset(n.children, dx, dyBase);
                        });
                    };

                    applyOffset(childrenToAdd, offsetX, 0);

                    // æ·»åŠ åˆ°å½“å‰èŠ‚ç‚¹
                    parent.node.children = parent.node.children || [];
                    parent.node.children.push(...childrenToAdd);
                    parent.node.collapsed = false;

                    renderAll();
                    setStatus(`å·²åˆå¹¶ ${childrenToAdd.length} ä¸ªå­èŠ‚ç‚¹åˆ°å³ä¾§`);
                } catch (err) {
                    alert('åˆå¹¶å¤±è´¥ï¼š' + err.message);
                }
            };
            input.click();
        }

        /* æ·»åŠ æŒ‰é’®åˆ°å·¥å…·æ  */
        document.addEventListener('DOMContentLoaded', () => {
            const toolbar = document.querySelector('.toolbar');
            const btnMerge = document.createElement('button');
            btnMerge.className = 'btn';
            btnMerge.textContent = 'åˆå¹¶å¯¼å…¥ JSON';
            btnMerge.onclick = mergeImportJSON;
            toolbar.appendChild(btnMerge);
        });
        document.addEventListener('click', e => {
            if (e.target && e.target.id === 'btnSelectSubtree') {
                const nodeId = appState.editing;          // å½“å‰æ­£åœ¨ç¼–è¾‘çš„èŠ‚ç‚¹
                if (!nodeId) return;

                // æ¸…ç©ºæ—§é€‰ä¸­
                appState.selected.clear();

                // æŠŠå½“å‰èŠ‚ç‚¹åŠ å…¥
                appState.selected.add(nodeId);

                // é€’å½’æŠŠå…¨éƒ¨åä»£ä¹ŸåŠ å…¥
                const collectIds = (n) => {
                    if (n.children) {
                        n.children.forEach(c => {
                            appState.selected.add(c.id);
                            collectIds(c);
                        });
                    }
                };
                const root = findById(nodeId)?.node;
                if (root) collectIds(root);

                // ç«‹å³åˆ·æ–°è§†å›¾
                renderNodes();
                setStatus(`å·²é€‰ä¸­ ${appState.selected.size} ä¸ªèŠ‚ç‚¹ï¼Œå¯æ•´ä½“æ‹–åŠ¨`);
                hidePanel();  // å…³é—­é¢æ¿
            }
        });
        /*****************************************************************
 *  1. ç»™é¢æ¿æ·»åŠ ã€Œå…¨é€‰å­èŠ‚ç‚¹ã€æŒ‰é’®
 *****************************************************************/
        const oldShowPanel = window.showPanel;
        window.showPanel = function (x, y, node) {
            oldShowPanel(x, y, node);

            // æ‰¾åˆ°â€œä¿®æ”¹çˆ¶èŠ‚ç‚¹â€æ‰€åœ¨çš„è¡Œ
            const changeBtn = document.getElementById('pChangeParent');
            if (!changeBtn) return; // ä¿é™©

            // å¦‚æœæŒ‰é’®å·²å­˜åœ¨åˆ™è·³è¿‡
            if (changeBtn.parentElement.querySelector('#btnSelectSubtree')) return;

            // åˆ›å»ºæŒ‰é’®
            const btn = document.createElement('button');
            btn.className = 'btn';
            btn.id = 'btnSelectSubtree';
            btn.textContent = 'å…¨é€‰å­èŠ‚ç‚¹';
            btn.onclick = () => {
                selectSubtree(node.id);
                hidePanel();
            };

            // æ’å…¥åˆ°â€œä¿®æ”¹çˆ¶èŠ‚ç‚¹â€æŒ‰é’®åé¢
            changeBtn.after(btn);
        };

        /*****************************************************************
         *  2. é€‰ä¸­èŠ‚ç‚¹+æ‰€æœ‰åä»£ï¼Œå¹¶è¿›å…¥â€œæ•´ä½“æ‹–åŠ¨â€æ¨¡å¼
         *****************************************************************/
        function selectSubtree(rootId) {
            appState.selected.clear();

            // æ ¹èŠ‚ç‚¹
            appState.selected.add(rootId);

            // é€’å½’åä»£
            const collect = (n) => {
                if (n.children) {
                    n.children.forEach(c => {
                        appState.selected.add(c.id);
                        collect(c);
                    });
                }
            };
            const r = findById(rootId);
            if (r) collect(r.node);

            // è¿›å…¥â€œæ•´ä½“æ‹–åŠ¨â€çŠ¶æ€
            appState.draggingSubtree = true;
            renderNodes();
            setStatus(`å·²é€‰ä¸­ ${appState.selected.size} ä¸ªèŠ‚ç‚¹ï¼Œæ‹–åŠ¨ä»»æ„ä¸€ä¸ªå³å¯æ•´ä½“ç§»åŠ¨`);
        }

        /*****************************************************************
         *  3. ä¿®æ”¹èŠ‚ç‚¹ç‚¹å‡»é€»è¾‘ï¼šæ•´ä½“æ‹–åŠ¨æœŸé—´ä¸é‡æ–°é€‰ä¸­
         *****************************************************************/
        const oldOnNodeMouseDown = window.onNodeMouseDown;
        window.onNodeMouseDown = function (e) {
            // å¦‚æœæ­£å¤„äºæ•´ä½“æ‹–åŠ¨æ¨¡å¼
            if (appState.draggingSubtree) {
                e.stopPropagation();           // ä¸å†è§¦å‘æ—§é€»è¾‘
                const gid = e.currentTarget.dataset.id;
                if (!appState.selected.has(gid)) return; // ä»…å¤„ç†å·²é€‰èŠ‚ç‚¹

                // å¼€å§‹æ•´ä½“æ‹–æ‹½
                const worldPos = toWorld(
                    e.clientX - stage.getBoundingClientRect().left,
                    e.clientY - stage.getBoundingClientRect().top
                );
                appState.dragging = { ids: [...appState.selected], start: worldPos };
                window.addEventListener('mousemove', onSubtreeDragMove);
                window.addEventListener('mouseup', onSubtreeDragEnd, { once: true });
                return;
            }

            // å¦åˆ™èµ°åŸæ¥çš„é€»è¾‘
            oldOnNodeMouseDown.call(this, e);
        };

        /*****************************************************************
         *  4. æ•´ä½“æ‹–æ‹½å®ç°ï¼šæ‰¹é‡ç§»åŠ¨åæ ‡
         *****************************************************************/
        function onSubtreeDragMove(e) {
            if (!appState.dragging) return;
            const wp = toWorld(
                e.clientX - stage.getBoundingClientRect().left,
                e.clientY - stage.getBoundingClientRect().top
            );
            const dx = wp.x - appState.dragging.start.x;
            const dy = wp.y - appState.dragging.start.y;

            appState.dragging.ids.forEach(id => {
                const r = findById(id);
                if (r) {
                    r.node.x += dx;
                    r.node.y += dy;
                    r.node.__manual = true; // æ ‡è®°ä¸ºæ‰‹åŠ¨ä½ç½®
                }
            });
            appState.dragging.start = wp;
            renderEdges();
            renderNodes();
            updateMiniMap();
        }

        function onSubtreeDragEnd() {
            commitHistory('drag subtree');
            window.removeEventListener('mousemove', onSubtreeDragMove);
            appState.dragging = null;
            appState.draggingSubtree = false; // é€€å‡ºæ•´ä½“æ‹–åŠ¨æ¨¡å¼
            setStatus('å­æ ‘ç§»åŠ¨å®Œæˆ');
        }

        /*****************************************************************
         *  5. Esc é”®å–æ¶ˆæ•´ä½“æ‹–åŠ¨æ¨¡å¼
         *****************************************************************/
        document.addEventListener('keydown', e => {
            if (e.key === 'Escape') {
                appState.draggingSubtree = false;
                setStatus('å·²é€€å‡ºæ•´ä½“æ‹–åŠ¨æ¨¡å¼');
            }
        });
        // åˆ¤æ–­èŠ‚ç‚¹æ˜¯å¦è¢«æŸä¸ªæŠ˜å ç¥–å…ˆéšè—
        function isNodeHiddenByAncestor(node) {
            let p = findParent(node);
            while (p) {
                if (p.node && p.node.collapsed) return true;   // åŠ  p.node ä¿æŠ¤
                p = findParent(p.node);
            }
            return false;
        }

        // è¿”å›ç¬¬ä¸€ä¸ªæœªæŠ˜å ç¥–å…ˆèŠ‚ç‚¹å¯¹è±¡
        function firstUnCollapsedAncestor(node) {
            let p = findParent(node);
            while (p) {
                if (p.node && !p.node.collapsed) return p.node;
                p = findParent(p.node);
            }
            return null;
        }

        // é€šç”¨ï¼šç»™å®šå­èŠ‚ç‚¹ï¼Œæ‰¾åˆ°çˆ¶èŠ‚ç‚¹ä¿¡æ¯
        function findParent(childNode) {
            let res = null;
            walk(model, (n, parent) => {
                if (n === childNode) res = { node: parent };
            });
            return res;   // å¯èƒ½è¿”å› null
        }
        /* ===== 1. å¹³è¡Œæ’å¸ƒå¼€å…³ ===== */
        let parallelLayout = false;   // æ˜¯å¦å¤„äºå¹³è¡Œæ’å¸ƒ

        /* å¹³è¡Œæ’å¸ƒè®¡ç®—å‡½æ•° */
        function layoutChildrenParallel(parent) {
            const gap = 40;              // ä¸Šä¸‹é—´è·
            const totalH = parent.children.reduce((s, c) => s + (c.style?.h || 28) + gap, 0) - gap;
            let curY = parent.y - totalH / 2;

            parent.children.forEach(c => {
                c.x = parent.x + 160;      // ç»Ÿä¸€æ°´å¹³ä½ç½®ï¼Œå¯éšæ„æ”¹
                c.y = curY + (c.style?.h || 28) / 2;
                curY += (c.style?.h || 28) + gap;
            });
        }

        /* é”®ç›˜ç›‘å¬ï¼šY é”®åˆ‡æ¢ */
        document.addEventListener('keydown', e => {
            if (e.key.toLowerCase() !== 'y' || e.metaKey || e.ctrlKey) return;
            e.preventDefault();

            const r = findById(currentId());
            if (!r || !r.node.children?.length) return;

            parallelLayout = !parallelLayout;

            if (parallelLayout) {
                layoutChildrenParallel(r.node);
                resolveOverlaps();         // é˜²é‡å 
                renderAll();
                setStatus('å·²åˆ‡æ¢ä¸ºå¹³è¡Œæ’å¸ƒ');
            } else {
                renderAll();               // å›é€€è‡ªåŠ¨æ ‘å½¢å¸ƒå±€
                setStatus('å·²æ¢å¤æ ‘å½¢å¸ƒå±€');
            }
        });
        
        let autoLayoutEnabled = false;

        const btnAutoLayout = document.getElementById('btnAutoLayout');
        btnAutoLayout.onclick = () => {
            autoLayoutEnabled = !autoLayoutEnabled;
            btnAutoLayout.classList.toggle('active', autoLayoutEnabled);
            setStatus('è‡ªåŠ¨æ•´ç†å·²' + (autoLayoutEnabled ? 'å¼€å¯' : 'å…³é—­'));
        };

        /* è¦†ç›–åŸ toggleCollapseï¼ˆä¿ç•™åŸæœ‰é€»è¾‘ï¼Œè¿½åŠ è‡ªåŠ¨æ•´ç†ï¼‰ */
        const oldToggleCollapse = window.toggleCollapse;
        window.toggleCollapse = function (id) {
            oldToggleCollapse(id);          // å…ˆæ‰§è¡ŒåŸæŠ˜å /å±•å¼€
            if (!autoLayoutEnabled) return; // å¼€å…³å…³é—­å°±ç»“æŸ

            /* æ”¶é›†å½“å‰èŠ‚ç‚¹åŠå…¶æ‰€æœ‰åä»£èŠ‚ç‚¹ id */
            const ids = [];
            function collectIds(node) {
                ids.push(node.id);
                (node.children || []).forEach(collectIds);
            }
            const r = findById(id);
            if (r) collectIds(r.node);

            /* é‡ç½®è¿™äº›èŠ‚ç‚¹çš„ __manual æ ‡è®°ï¼ˆç›¸å½“äº Shift+Rï¼‰ */
            ids.forEach(id => {
                const t = findById(id);
                if (t) delete t.node.__manual;
            });

            /* é‡æ–°å¸ƒå±€ä¸€æ¬¡ */
            commitHistory('auto reset layout');
            renderAll();
        };
        /* ========= ç•Œé¢ â–¼ ä¸‹æ‹‰ ========= */
        const uiBtn = document.getElementById('UIMenu');
        const uiPanel = document.getElementById('uiDropdown');

        /* ç‚¹å‡»æŒ‰é’®å¼€å…³ä¸‹æ‹‰ */
        uiBtn.addEventListener('click', () => {
            uiPanel.style.display = uiPanel.style.display === 'none' ? 'block' : 'none';
        });

        /* ç‚¹å‡»ç©ºç™½å…³é—­ä¸‹æ‹‰ */
        window.addEventListener('click', e => {
            if (!uiBtn.contains(e.target) && !uiPanel.contains(e.target)) {
                uiPanel.style.display = 'none';
            }
        });

        /* æŠŠæ—§æŒ‰é’®äº‹ä»¶æŒ‚åˆ°æ–°æŒ‰é’®ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼‰ */
        ['Note', 'Link', 'Image', 'Task', 'Tag', 'Style'].forEach(name => {
            const oldBtn = document.getElementById('btn' + name);
            const newBtn = document.getElementById('btn' + name + 'UI');
            if (oldBtn && newBtn) newBtn.onclick = oldBtn.onclick;
        });
       
    </script>
</body>
</html>




